(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3448],{48952:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=48952,e.exports=t},37545:(e,t,i)=>{"use strict";i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>m,frontMatter:()=>r,metadata:()=>c,toc:()=>h});var n=i(17624),o=i(4552),a=i(96020);const s="import * as Kilt from '@kiltprotocol/sdk-js'\n\nimport { mnemonicGenerate } from '@polkadot/util-crypto'\n\nexport function generateKeypairs(mnemonic = mnemonicGenerate()): {\n  authentication: Kilt.KiltKeyringPair\n  keyAgreement: Kilt.KiltEncryptionKeypair\n  assertionMethod: Kilt.KiltKeyringPair\n  capabilityDelegation: Kilt.KiltKeyringPair\n} {\n  const authentication = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const assertionMethod = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const capabilityDelegation = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const keyAgreement = Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(\n    Kilt.Utils.Crypto.mnemonicToMiniSecret(mnemonic)\n  )\n\n  return {\n    authentication: authentication,\n    keyAgreement: keyAgreement,\n    assertionMethod: assertionMethod,\n    capabilityDelegation: capabilityDelegation\n  }\n}\n",r={id:"key-generation",title:"Generate DID keys"},d=void 0,c={id:"develop/sdk/cookbook/dids/key-generation",title:"Generate DID keys",description:"Creating a Decentralized Identifier (DID) on the KILT network involves generating keying material for authentication and encryption.",source:"@site/docs/develop/01_sdk/02_cookbook/01_dids/00_generate_keys.md",sourceDirName:"develop/01_sdk/02_cookbook/01_dids",slug:"/develop/sdk/cookbook/dids/key-generation",permalink:"/docs/develop/sdk/cookbook/dids/key-generation",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/01_dids/00_generate_keys.md",tags:[],version:"current",lastUpdatedAt:1708580324,formattedLastUpdatedAt:"Feb 22, 2024",sidebarPosition:0,frontMatter:{id:"key-generation",title:"Generate DID keys"},sidebar:"sdk",previous:{title:"Quickstart",permalink:"/docs/develop/sdk/quickstart"},next:{title:"Create a Light DID",permalink:"/docs/develop/sdk/cookbook/dids/light-did-creation"}},l={},h=[{value:"Derivation paths",id:"derivation-paths",level:2},{value:"Soft derivation",id:"soft-derivation",level:2},{value:"Hard derivation",id:"hard-derivation",level:2},{value:"Creating new accounts from a seed",id:"creating-new-accounts-from-a-seed",level:2}];function p(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",...(0,o.M)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Creating a Decentralized Identifier (DID) on the KILT network involves generating keying material for authentication and encryption.\nThis guide shows how to create a set of key pairs suitable for generating a KILT DID."}),"\n",(0,n.jsxs)(t.p,{children:["Before proceeding, it's important to note that this example assumes the usage of the ",(0,n.jsx)(t.code,{children:"@kiltprotocol/sdk-js"})," library along with the ",(0,n.jsx)(t.code,{children:"@polkadot/util-crypto"})," library for cryptographic operations."]}),"\n",(0,n.jsx)(t.p,{children:"Additionally, it's important to securely store keys and the mnemonic seed phrase.\nFor production use, ensure that private keys are encrypted and stored safely, while also creating a backup of the mnemonic seed phrase."}),"\n",(0,n.jsx)(t.h2,{id:"derivation-paths",children:"Derivation paths"}),"\n",(0,n.jsx)(t.p,{children:"The code example below derives different types of keys from a single account using derivation paths."}),"\n",(0,n.jsxs)(t.p,{children:["A derivation path is a way to derive a new key from a parent key and is a sequence of indices separated by a delimiter.\nThe most common delimiter is ",(0,n.jsx)(t.code,{children:"/"})," (forward slash)."]}),"\n",(0,n.jsx)(t.p,{children:"KILT uses the same derivation paths as the underlying Polkadot libraries, using soft and hard key derivation."}),"\n",(0,n.jsx)(t.h2,{id:"soft-derivation",children:"Soft derivation"}),"\n",(0,n.jsx)(t.p,{children:"A soft derivation allows someone to potentially figure out the initial account's private key if they know the derived account's private key.\nIt is also possible to determine that different accounts generated from the same seed are linked to that seed."}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"/"})," (single slash) indicates a soft derivation path.\nFor example, ",(0,n.jsx)(t.code,{children:"deal rice sunny now boss cluster team use wreck electric wing deliver/0"})," is a soft derivation path."]}),"\n",(0,n.jsx)(t.h2,{id:"hard-derivation",children:"Hard derivation"}),"\n",(0,n.jsx)(t.p,{children:"A hard derivation path does not allow someone to do either of these.\nEven if you know a derived private key, it's not possible to figure out the private key of the root address, and it's impossible to prove that the first account is linked with the second."}),"\n",(0,n.jsxs)(t.p,{children:["A ",(0,n.jsx)(t.code,{children:"//"})," (double slash) indicates a hard derivation path.\nFor example, ",(0,n.jsx)(t.code,{children:"deal rice sunny now boss cluster team use wreck electric wing deliver//0"})," is a hard derivation path."]}),"\n",(0,n.jsx)(t.h2,{id:"creating-new-accounts-from-a-seed",children:"Creating new accounts from a seed"}),"\n",(0,n.jsx)(t.p,{children:"This approach allows you to generate various key pairs for authentication, key agreement, assertion methods, and capability delegation from one mnemonic seed phrase."}),"\n",(0,n.jsxs)(t.p,{children:["To create another account using the same seed, change the number at the end of the string. For example, ",(0,n.jsx)(t.code,{children:"/1"}),", ",(0,n.jsx)(t.code,{children:"/2"}),", and ",(0,n.jsx)(t.code,{children:"/3"})," create different derived accounts."]}),"\n",(0,n.jsx)(t.p,{children:"Using derivation paths simplifies key management, ensuring that a single mnemonic seed serves as the basis for multiple keys associated with a DID.\nThis method improves efficiency while maintaining security.\nHowever, it's essential to handle and store private keys securely to prevent unauthorized access and ensure the overall integrity and privacy of the decentralized identity system."}),"\n",(0,n.jsx)(t.p,{children:"Below is an example code snippet illustrating the key pair generation for a KILT DID:"}),"\n",(0,n.jsx)(a.c,{children:s}),"\n",(0,n.jsx)(t.admonition,{type:"info",children:(0,n.jsx)(t.p,{children:"This example doesn't show how to store the keys.\nIt is recommended to store the keys in a secure manner, e.g. only storing the private keys encrypted on disk.\nThe mnemonic seed phrase can be used to regenerate the keys, so it is recommended to also store the mnemonic in a secure manner and create a backup of it."})})]})}function m(e={}){const{wrapper:t}={...(0,o.M)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(p,{...e})}):p(e)}},96020:(e,t,i)=>{"use strict";i.d(t,{c:()=>m});var n=i(11504),o=i(28264),a=i(46352),s=i(58440),r=i(14300),d=i(28168),c=i(61268),l=i(87768),h=i(1608),p=i(17624);const m=e=>{let{children:t,fileName:i,...m}=e;const u=t,[k,y]=(0,n.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:f}}}=(0,o.c)(),g=(0,n.useMemo)((()=>{const{code:e}=(0,a.transform)(u,{plugins:["transform-typescript"],retainLines:!0});return e}),[u]);(0,n.useEffect)((()=>{s.E9(g,{parser:"babel",plugins:[r.c,d.cp],...f}).then(y)}),[f,g]);const v=[{fileName:i?`${i}.ts`:void 0,fileContents:u,fileID:"ts",fileLabel:"Typescript"},{fileName:i?`${i}.js`:void 0,fileContents:k,fileID:"js",fileLabel:"Javascript"}];return(0,p.jsx)(p.Fragment,{children:(0,p.jsx)(c.c,{groupId:"ts-js-choice",children:v.map((e=>(0,p.jsx)(l.c,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,p.jsx)(h.c,{...m,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);