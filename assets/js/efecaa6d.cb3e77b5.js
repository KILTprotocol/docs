(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[6798],{5764:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5764,e.exports=t},2384:(e,t,i)=>{"use strict";i.r(t),i.d(t,{assets:()=>p,contentTitle:()=>l,default:()=>b,frontMatter:()=>c,metadata:()=>d,toc:()=>u});var n=i(4848),a=i(8453),o=i(3172);const s="import * as Kilt from '@kiltprotocol/sdk-js'\n\n// CType definition.\nconst ctype = Kilt.CType.fromProperties(`NFT Collection Certification CType`, {\n  name: {\n    type: 'string'\n  },\n  pieces: {\n    type: 'integer'\n  },\n  creationDate: {\n    type: 'string'\n  },\n  artistIdentity: {\n    type: 'string'\n  }\n})\n\nexport function createNftCollectionCredential(\n  assetDid: Kilt.AssetDidUri,\n  artistDid: Kilt.DidUri\n): Kilt.IPublicCredentialInput {\n  const claimProperties: Kilt.IClaimContents = {\n    name: 'Awesome NFT drop',\n    // NFT collection only has 100 pieces in total\n    pieces: 100,\n    // NFT collection was released on Jan 1st, 2023\n    creationDate: new Date(2023, 0, 1).toISOString(),\n    artistIdentity: artistDid\n  }\n  const fullClaim: Kilt.IAssetClaim = {\n    contents: claimProperties,\n    cTypeHash: Kilt.CType.idToHash(ctype.$id),\n    subject: assetDid\n  }\n\n  return Kilt.PublicCredential.fromClaim(fullClaim)\n}\n",r="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport async function issueCredential(\n  attester: Kilt.DidUri,\n  submitterAccount: Kilt.KiltKeyringPair,\n  signCallback: Kilt.SignExtrinsicCallback,\n  credential: Kilt.IPublicCredentialInput\n): Promise<void> {\n  const api = Kilt.ConfigService.get('api')\n\n  const credentialCreationTx = api.tx.publicCredentials.add(\n    Kilt.PublicCredential.toChain(credential)\n  )\n\n  // Same as for traditional KILT credentials\n  const authorizedAttestationTx = await Kilt.Did.authorizeTx(\n    attester,\n    credentialCreationTx,\n    signCallback,\n    submitterAccount.address\n  )\n  await Kilt.Blockchain.signAndSubmitTx(\n    authorizedAttestationTx,\n    submitterAccount\n  )\n}\n",c={id:"public-credential-issuance",title:"Credential Issuance"},l=void 0,d={id:"develop/sdk/cookbook/public_credentials/public-credential-issuance",title:"Credential Issuance",description:"As for traditional KILT credentials, public credentials also have their structure defined by a CType, although CTypes that can be used to represent information about assets would probably differ from the ones used to represent information about people.",source:"@site/docs/develop/01_sdk/02_cookbook/05_public_credentials/01_credential_issuance.md",sourceDirName:"develop/01_sdk/02_cookbook/05_public_credentials",slug:"/develop/sdk/cookbook/public_credentials/public-credential-issuance",permalink:"/docs/develop/sdk/cookbook/public_credentials/public-credential-issuance",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/05_public_credentials/01_credential_issuance.md",tags:[],version:"current",lastUpdatedAt:1733496053e3,sidebarPosition:1,frontMatter:{id:"public-credential-issuance",title:"Credential Issuance"},sidebar:"sdk",previous:{title:"Revoke a Credential",permalink:"/docs/develop/sdk/cookbook/claiming/attestation-removal"},next:{title:"Retrieve Public Credentials",permalink:"/docs/develop/sdk/cookbook/public_credentials/public-credential-retrieval"}},p={},u=[{value:"Create and Issue the Credential",id:"create-and-issue-the-credential",level:2}];function h(e){const t={a:"a",admonition:"admonition",h2:"h2",p:"p",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(t.p,{children:["As for traditional KILT credentials, public credentials also have their structure defined by a ",(0,n.jsx)(t.a,{href:"/docs/concepts/credentials/ctypes",children:"CType"}),", although CTypes that can be used to represent information about assets would probably differ from the ones used to represent information about people."]}),"\n",(0,n.jsx)(t.p,{children:"As mentioned in the section about credentials, the creation of a CType in KILT involves two steps: the definition of a CType and the anchoring of its hash on the KILT blockchain."}),"\n",(0,n.jsxs)(t.p,{children:["We will not cover the creation of a CType, please refer to the ",(0,n.jsx)(t.a,{href:"/docs/develop/sdk/cookbook/claiming/ctype-creation",children:"CType creation"})]}),"\n",(0,n.jsx)(t.h2,{id:"create-and-issue-the-credential",children:"Create and Issue the Credential"}),"\n",(0,n.jsx)(t.p,{children:"Using the existing CType, the new public credential object can be created with the actual content, and then written to the chain for the rest of the KILT users (and beyond) to consume."}),"\n",(0,n.jsx)(t.p,{children:"Creating a public credential is as simple as creating an object that conforms to the required structure of the CType:"}),"\n",(0,n.jsx)(o.A,{children:s}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"The creation of the credential object does not require any interaction with the blockchain per se.\nThis also means that, until the object is written to the blockchain (see below), it cannot be used/retrieved/verified by anyone else, so it is, by all means, not existing."})}),"\n",(0,n.jsx)(t.p,{children:"Once the credential object is created, it must be written to the blockchain for other people to be able to use it."}),"\n",(0,n.jsx)(o.A,{children:r}),"\n",(0,n.jsx)(t.admonition,{title:"Credential has to be CBOR-encoded!",type:"info",children:(0,n.jsx)(t.p,{children:"Given a public credential object, the SDK internally CBOR-encodes it before firing the extrinsic to the blockchain!\nThis is to save space on credentials that actually benefit from CBOR compression (e.g., if they contain a lot of binary information).\nHence, creating public credentials without the SDK requires the credential to be CBOR-encoded!"})})]})}function b(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},3172:(e,t,i)=>{"use strict";i.d(t,{A:()=>h});var n=i(6540),a=i(4586),o=i(6352),s=i(8463),r=i(5283),c=i(6745),l=i(1470),d=i(9365),p=i(1432),u=i(4848);const h=e=>{let{children:t,fileName:i,...h}=e;const b=t,[f,m]=(0,n.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:C}}}=(0,a.A)(),y=(0,n.useMemo)((()=>{const{code:e}=(0,o.transform)(b,{plugins:["transform-typescript"],retainLines:!0}),t=["./generateAccount","./generateKeypairs","./ctypeSchema","./createClaim","./generateLightDid","../attester/ctypeSchema","../claimer/generateLightDid","../claimer/generateCredential","./claimer/createPresentation","./claimer/generateKeypairs","./claimer/generateLightDid"];let i=e.replace(/from\s+['"](.+)['"]/g,((e,i)=>t.includes(i)?`from '${i}.js'`:e));return i=i.replace("if (require.main === module)","if (process.argv[1] === new URL(import.meta.url).pathname)"),i}),[b]);(0,n.useEffect)((()=>{s.GP(y,{parser:"babel",plugins:[r.A,c.Ay],...C}).then(m)}),[C,y]);const g=[{fileName:i?`${i}.ts`:void 0,fileContents:b,fileID:"ts",fileLabel:"Typescript"},{fileName:i?`${i}.js`:void 0,fileContents:f,fileID:"js",fileLabel:"Javascript"}];return(0,u.jsx)(u.Fragment,{children:(0,u.jsx)(l.A,{groupId:"ts-js-choice",children:g.map((e=>(0,u.jsx)(d.A,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,u.jsx)(p.A,{...h,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);