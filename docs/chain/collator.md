---
id: collator
title: Become a collator
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


We will guide you through the steps to become a collator.
First we will discuss the hardware requirements and how you could test your performance.
After that we go over a few configurations options and show you how to start a collator.
When your collator is running you still need to register on chain.
We will show you how to obtain your session keys and become a collator candidate.

## Hardware Requirements

The following hardware was used to benchmark the KILT blockchain and calculate the extrinsic weights.
Your hardware should at least be as fast as the hardware used for benchmarking.
Having a fast storage is important for the overall performance.

- OS - Ubuntu 20.04.2
- CPU - AMD Ryzen 7 1700X
- Storage - A NVMe solid-state drive. Should be reasonably sized to deal with blockchain growth. Starting around 80GB - 160GB will be okay for the first six months of KILT's parachain and Kusama relay chain but will need to be re-evaluated every six months.
- Memory - 16GB

The specification posted above are by no means the minimum specs that you could use when running a collator, however you should be aware that if you are using less you may need to toggle some extra optimizations in order to be equal to other collators that are running the standard.

You can compare your hardware with the above listed hardware by running the benchmarks.
If your benchmark results are better (smaller weights) than ours, your hardware is faster than the required minimum.
The results of the spiritnet benchmarks can be found [here](https://github.com/KILTprotocol/mashnet-node/tree/develop/runtimes/spiritnet/src/weights).
You can find [a guide on how to run benchmarks](#Benchmarking-(optional)) further below.

## Start a Node

There are several ways to build and test a collator node.
**These commands are based on commits.**
The time needed to start a node depends on the method chosen.
We will go through how to use a Docker image or compile directly from our chain repository.
There are currently two different runtimes that can be executed:

- The `peregrine` chain is as close to our official chain as possible and is to be considered our public test network. It can be used to try things out before doing them on the live chain, which typically involves spending tokens that have real monetary value.
- The `spiritnet` chain is our official public network and contains only stable features.

Each runtime has its own benchmark measurements.

### Configuration

Running a collator requires a few configuration parameters.
Some of the parameters might appear twice in the command that start the collator.
The reason for that is, that a parachain collator actually runs two blockchains.
The parameter that are listed before the `--` are related to the parachain node itself (the KILT blockchain), whereas the parameters following the `--` are related to the relaychain, i.e., Kusama or Polkadot.

Following is a description of some of the parameters that can be set when spinning up a parachain collator node.

#### RPC Endpoint

Our collator needs session keys that connect your collator with your KILT account.
These session keys can be generated by calling an RPC endpoint that your collator optionally exposes.
Exposing the RPC endpoints can be done using the following parameters:

```
--rpc-port=9933
--rpc-cors=all
--rpc-methods=unsafe
```

With these parameters you can make RPC calls directly using curl.
But you won't be able to connect to the node with the polkadot apps.
The polkadot apps UI tries to connect to your node via a Websocket connection.
You can use the following arguments for exposing the Websocket endpoint:

```
--ws-port=9944
```

If you want to connect from a remote host to your RPC endpoints (e.g. using the polkadot apps) you will need to expose the RPC endpoints.
This can be done using the following arguments:

```
--ws-external
--rpc-external
```

:::danger

Be aware that this might **expose your collator**!
You should be the only one able to call the RPC endpoints.
For a secure setup, follow the instructions in the section about [generating the session keys](#generating-session-keys)

:::

#### Execution Wasm

We pass the `--execution=wasm` parameter to both the relaychain and parachain since we don't want the faster native execution.
The native execution might be faster but can also deviate from the WASM execution and result in a different state.
When this happens your collator will crash and will stop producing blocks.
Since the WASM is the single truth and is part of the blockchain state itself, all collators should execute the WASM version of the state transition function.

#### Select which runtime and chain to use

The `--chain` parameter decides which blockchain we want to execute.
We need to pass this parameter to the parachain and the relaychain, since both chains are separate blockchains.
The KILT parachain accepts an additional runtime parameter to select which runtime is executed.
This can either be `peregrine` or `spiritnet`.
For now this parameter is not required, since both runtimes are very similar and can run in the same environment, but it is safer to provide it already now.

#### Where are all the files stored?

The `--base-path` parameter configures where all the persistent files are written.
By default the session keys will also be stored in the *base path*, but we recommend to separate them from the other files.
This makes sure that the keyfiles are not accidentally lost or published when you backup or restore your blockchain database.
You can configure where to store the session keys using the `--keystore-path` option.
Since you only use session keys for the parachain, there is no need to add this to the relaychain part of the command.

### Run a Peregrine collator

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Binary', value: 'Binary'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Binary">

We recommend following the instructions in our [chain repository](https://github.com/KILTprotocol/mashnet-node).
Below is the command to build the KILT collator executable for the Peregrine network, which must be run from the root directory of the repository.

:::info

Do not use the `develop` branch to build the executable.
Either use `master` or the the latest released version.

:::


```bash
./scripts/init.sh
cargo build --release -p kilt-parachain
```

The executable file can be found in `./target/release/kilt-parachain` after building the project.

</TabItem>
<TabItem value="Docker">

Simply pull the docker image:

```bash
docker pull kiltprotocol/kilt-node:latest
```

</TabItem>
</Tabs>

### Start the node

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Binary', value: 'Binary'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Binary">


```
./target/release/kilt-parachain \
  --chain=./dev-specs/kilt-parachain/peregrine-kilt.json \
  --runtime=peregrine \
  --rpc-port=9933 \
  --rpc-cors=all \
  --rpc-methods=unsafe \
  --name "name of collator" \
  --execution=wasm \
  --listen-addr=/ip4/0.0.0.0/tcp/30336 \
  --base-path $HOME/data/parachain \
  --keystore-path $HOME/data/keystore \
  --collator \
  -- \
  --listen-addr=/ip4/0.0.0.0/tcp/30333 \
  --base-path $HOME/data/relay \
  --chain=./dev-specs/kilt-parachain/peregrine-relay.json \
  --execution=wasm
```

If you want to be able to reach your own node via PolkadotJS Apps, add a `--ws-external` option to the collator options, before the `--` divider.

</TabItem>
<TabItem value="Docker">

```bash=
docker run -p 127.0.0.1:9933:9933 -v ~/data:/data \
    kiltprotocol/kilt-node:latest \
    --rpc-port=9933 \
    --rpc-cors=all \
    --rpc-methods=unsafe \
    --chain=/node/dev-specs/kilt-parachain/peregrine-kilt.json \
    --runtime=peregrine \
    --execution=wasm \
    --listen-addr=/ip4/0.0.0.0/tcp/30336 \
    --name "name of collator" \
    --base-path /data/parachain \
    --keystore-path /data/keystore \
    --collator \
    -- \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --base-path /data/relay \
    --chain=/node/dev-specs/kilt-parachain/peregrine-relay.json \
    --execution=wasm
```

If you want to be able to reach your own node via PolkadotJS Apps, add a `--ws-external` option to the collator options, before the `--` divider, and expose the container port with an additional `-p 9944:9944` parameter.

The docker commands will map the database files for the relay and parachain as well as the keystore directory to `~/data` on your host system using the flag `-v $HOME/data:/data`.
That way you can make sure to not lose those files when you remove the container.

The docker container runs as an user with id 1000.
The container will try to access the mapped volume and the files in it.
If the files are not owned by a user with id 1000 this will result in an error.
Run `chown -R 1000:1000 $HOME/data` to give the container access.


</TabItem>
</Tabs>

## Sync Data

Before a collator can author blocks, the node needs to fully sync up with both the KILT parachain and the Kusama relay chain.
Depending on which chain and the size of it may take a number of minutes to several hours maybe even a day.

More details can be found on the [Polkadot network docs](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-kusama#synchronize-chain-data)

## Session Keys

Once the chain has fully synced, the collator will need sessions keys to begin collating on the network.
A collator can call a RPC to check whether the account has session keys with the following calls `hasKey` and `hasSessionKeys` in `author`.

![](/img/chain/author-hasKey.png)

:::note

The Session keys associate a collator node with an account on KILT.

:::

### Generate Session Keys {#generating-session-keys}

:::warning

Make sure that nobody but yourself is able to access the RPC endpoint of your collator. Use SSH forwarding for the RPC port when needing to perform some RPC operations on the node with `ssh -L 127.0.0.1:9944:127.0.0.1:9944 <user>@<server>`

:::

There are tree ways to create the session keys.
We recommend using the curl command on the same host that your node is running or from a host that has an active SSH tunnel with your node.
This way you don't need to add the `--unsafe-rpc-external` argument to your node.
Nevertheless, the session keys can also be rotated using the polkadot apps interface.


<Tabs
  defaultValue="curl"
  values={[
    {label: 'curl', value: 'curl'},
    {label: 'Apps', value: 'apps'},
    {label: 'Subkey', value: 'subkey'},
  ]}>
<TabItem value="curl">

#### Curl command

A collator can use the following command to rotate the session key.

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "author_rotateKeys", "params":[]}' http://localhost:9933
```

The answer should look like the JSON object below.
The `result` key is the HEX-encoded public half of your newly created session key.

```
{"jsonrpc":"2.0","result":"0xb2dc33b1ff0c6f8b07f882236bb992e903452791ff5225b5eb4c2c1a40252d5d","id":1}
```

</TabItem>
<TabItem value="apps">

In order to use the PolkadotJS Apps UI, the node websocket endpoint must be reachable. This can be done either by public exposing it, which is discoraged, or by setting up an SSH tunnel for the websocket endpoint with `ssh -L 127.0.0.1:9933:127.0.0.1:9933 <user>@<server>`. If the latter option is chosen, there is no need to have a separate SSH tunnel for RPC traffic as all the RPC operations can be performed directly from the PolkadotJS Apps interface.

![](/img/chain/chain-menu.png)

![](/img/chain/chain-selection.png)

After connecting to the node, a collator must use an RPC with the associated collator account to generate the keys.
This call is under **Developer** > **RPC calls** for the **author** > **rotateKeys()** RPC function.
This will generate a new session key which replaces the existing one.

![](/img/chain/author-rotateKeys.png)

The rotation of the session key should be done periodically to ensure that the collator can remain secure and safe from attack.

</TabItem>
<TabItem value="subkey">

A keypair can be created using the [subkey tool](https://substrate.dev/docs/en/knowledgebase/integrate/subkey) by following the steps in the tool's official documentation.
The generated private and public keys can then be saved within the keystore folder of the collator node to be used as session keys.

```
❯ subkey generate -n kilt
Secret phrase `very secure private key you should not use the example private key` is account:
  Secret seed:      0xcafe97b4b8f0adc1adeb3feef30bf2e5b9d49ddd897f268c8027c850DeadBEEF
  Public key (hex): 0xda3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010
  Account ID:       0xda3861a45e0197f3ca145c2c209f9126e5053asdg03e459af4255cf8011d51010
  SS58 Address:     4srC1aowD94H9UH9xsnfv7XV6oHU6dhCymKYZHWKsdddaP29
```

The name of the file must be the *public* key prepended with `61757261` (hex representation of `aura`) and without the `0x` prefix, while the content of the file has to be the secret phrase.

![](/img/chain/session-key-file.png)

For instance, with the keypair generated in the example above, the session key file would be stored at the path `./keystores/61757261da3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010`.

</TabItem>
</Tabs>

Once a new session key is generated, the collator must then link that key to its own account in order to receive rewards for producing new blocks.
This operation is performed by submitting a signed extrinsic to the blockchain.
Visit the [polkadot apps and connect to the peregrine network](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fperegrine.kilt.io#/explorer) (websocket address: `wss://peregrine.kilt.io`).

`Developer -> Extrinsics -> Submission`

1. Select your collator's KILT address as the extrinsic submitter (the *using the selected account* field)
2. Submit the following extrinsic: `session -> setKeys(keys, proof)`
    - `keys` -> the public session key (`0xda3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010` in the example above)
    - `proof` -> the proof of ownership. It can be set to `0x00`

Once the extrinsic is executed by the blockchain, the collator has now linked the new session key to its account and can start receiving rewards for producing new blocks.

![](/img/chain/session-setKeys.png)

:::info

A session takes 600 blocks or around 120~ minutes

:::

## Add collator

:::warning

These steps should be followed only once a collator node has successfully linked a session key to its address by following the steps above.

:::

The maximum number of collators on Peregrine is currently 16.

A collator staking amount must be:
- minimum 10,000 KILT tokens 
- maximum 200,000 KILT tokens.

### Join collators

The collator must call an extrinsic from the `parachainStaking -> joinCandidates(stake)` with the desired stake to join the `candidatePool`.

`Developer -> Extrinsics -> Submission`

1. Select your collator's KILT address as the extrinsic submitter (the *using the selected account* field)
2. Submit the following extrinsic: `parachainStaking -> joinCandidates(stake)`
3. Insert the staked KILT amount for the collator

:::info

A recent change in the blockchain metadata resulted in a change in the UI regarding how balances are shown. In the current version of PolkadotJS Apps, 1 KILT requires adding 15 trailing `0`s. So, for instance, 1 KILT needs to be written as `1000000000000000`, while 10000 KILT would be `10000000000000000000`. If this changes again in the future, we will make sure to promptly notify our community.

:::

![](/img/chain/parachainStaking-joinCandidates.png)

A collator can check the current top candidates to see the position and required staked amount to join the network. 

`Developer -> Chain state -> Storage`

1. Selected state query: `parachainStaking -> topCandidates(): ParachainStakingSetOrderedSet`
2. Execute the query by pressing the "+" button on the right side

If the collator has enough self-stake and delegator stake it will be selected to collate.
Once the collator has been chosen, it will be part of the `topCandidates()` pool.
A time period of two sessions must pass before the collator will be authoring blocks, e.g.
after the rest of current session and the entire next one.

![](/img/chain/session-validators.png)

### Stake on collator

A collator can increase/decrease their stake.
The corresponding methods can be found as an extrinsic under `parachainStaking -> candidateStakeMore(more) / candidateStakeLess(less`.

![](/img/chain/parachainStaking.png)

## Monitoring

It would be ideal if monitoring is performed from a different host.
However in cases of limited resources it can also be run on the same machine where the collator is running.
There are two types of metrics we are going to collect. **Node Exporter Metrics** and **Blockchain Metrics.**
You can either run grafana on your own or subscribe to the free [grafana cloud](https://grafana.com/products/cloud/) option. 

:::info

If you want to use cloud-based solutions, you need to expose the prometheus process to allow remote access via a reverse proxy.
We recommend the following monitoring stack.
- Prometheus
- Grafana
- Node exporter
- Slack
- Nginx

:::

### Prerequisite
Install latest version of docker-compose from the [official docker-compose installation guide](https://docs.docker.com/compose/install/)

Steps:

1. Clone or download our monitoring template from our [chain repo](https://github.com/KILTprotocol/docs)
2. Change directory to the above cloned project's collator directory: ```cd docs/collator```
3. Edit the `.env` file and insert grafana admin password
4. Run the following command if you want to install only prometheus and node exporter
   ```docker-compose up -d```
5. If you want to install prometheus with grafana ``` docker-compose up --profile grafana -d ```
6. if you want to install prometheus **and** grafana with  your collator  ``` docker-compose --profile collator --profile grafana up -d```

 Secure Endpoints:

- Install nginx with certbot ```sudo apt install nginx certbot python3-certbot-nginx ```
- If ufw is enabled allow Nginx Full : ```sudo ufw allow 'Nginx Full'```
- Generate SSL certificate : ```sudo certbot --nginx -d ${DOMAIN_OF_SERVER_NAME}```
- Enable certificate renewal    ```crontab -e``` and add at the end  of the file ```0 5 * * * /usr/bin/certbot renew --quiet```
- Reload nginx after you replace the default nginx file with prometheus endpoint (if you chose grafana cloud) or grafana endpoint (if grafana installed)
  ``` nano /etc/nginx/sites-enabled/default ``` 
  ```
   location / {
    proxy_pass http://localhost:9090/;    #proxy_pass http://localhost:3000/;
  
          }
  ```
- Enable basic Auth by replacing default pasxsword on prometheus.yml using  ``` htpasswd -nBC 10 "" | tr -d ':\n' ```

### Testing
You could open and check [localhost:3000 ](http://localhost:3000/d/JGBmHZI7k/kilt-spiritnet?orgId=1&refresh=10s) then authenticate with admin:ADMIN_PASSWORD you set in `.env` at step 3.

### Configuring Notification channel
Choose any of the available notification channels and follow the [Graphana documentation](https://grafana.com/docs/grafana/latest/alerting/old-alerting/notifications/) so that you get alerts and notifications.



## Bootnodes

The bootnodes are required to connect to the peer to peer network and discover additional peers.
The addresses are included in the chain spec, so there is no need to add them as a parameter to the start command.
For the sake of completeness the bootnodes are listed below:

* Peregrine parachain bootnodes:
  - `/dns4/bootnode.kilt.io/tcp/30340/p2p/12D3KooWALJtiCZzcUPVsCa5f5egGfQyFhPY67kKosDw95bJqK7M`
  - `/dns4/bootnode.kilt.io/tcp/30341/p2p/12D3KooWCRgcGtFRsvqxqgysiR6Ah9SAzUNkM12Ef9sy59ZEspSQ`
* Peregrine relaychain bootnodes:
  - `/dns4/bootnode.kilt.io/tcp/30350/p2p/12D3KooWEeezCpJauUmWw3zfgEtYzhZTc5LgukQYtGTMaZfzgVfE`
  - `/dns4/bootnode.kilt.io/tcp/30351/p2p/12D3KooWHq5j9tLdZEu4tnr6ii2k33zp5DCoKREQ6KzuabC9Gihu`
  - `/dns4/bootnode.kilt.io/tcp/30352/p2p/12D3KooWQ8iTGLH98zLz9BZmq5FXDmR1NytDsJ2VToXvcjvHV16a`
  - `/dns4/bootnode.kilt.io/tcp/30353/p2p/12D3KooWNWNptEoH443LVUgwC5kd7DBVoNYwQtJh6dp4TQxUsAST`

## Benchmarking (optional)

To enable benchmarking, the collator must enable the benchmarking feature from a new build of the `kilt-parachain`.

:::caution

Don't use this binary for running a collator!

:::

```bash=
cargo build --release -p kilt-parchain --features=runtime-benchmarks
```

The benchmarking can be run to compare hardware against the referenced hardware.
At the moment, we have benchmarked our Runtime on an AMD Ryzen 7 1700X with 64GB RAM and an NVMe SSD.
After executing the benchmarks on a Server compare the weights to the official weights.
Lower weights are always better.

The commands to execute the benchmarking can be found in our official [benchmarks](https://github.com/KILTprotocol/mashnet-node/tree/master/runtimes/peregrine/src/weights).

Below is an example of benchmarking for the the `balances` pallet.

```bash=
./target/release/kilt-parachain \
  benchmark \
  --chain=spiritnet-dev \
  --execution=wasm \
  --wasm-execution=Compiled \
  --heap-pages=4096 \
  --extrinsic=* \
  --pallet=parachain_staking \
  --steps=50 \
  --repeat=20 \
  --output \
  ./runtimes/spiritnet/src/weights/parachain_staking.rs \
  --template \
  ./.maintain/weight-template.hbs
```

## Connect to the Spiritnet

After you tested your setup on peregrine you might want to start collating on our official Spiritnet blockchain.
For that you need to change the chainspec used for the relaychain and parachain.
The relay chain will change from the peregrine-relay spec to the Kusama spec.
The parachain chainspec and runtime will also change from peregrine to spiritnet.

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Binary', value: 'Binary'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Binary">

```
./target/release/kilt-parachain \
  --chain=spiritnet \
  --runtime=spiritnet \
  --rpc-port=9933 \
  --rpc-cors=all \
  --rpc-methods=unsafe \
  --name "name of collator" \
  --execution=wasm \
  --listen-addr=/ip4/0.0.0.0/tcp/30336 \
  --base-path $HOME/data/parachain \
  --keystore-path $HOME/data/keystore \
  --collator \
  -- \
  --listen-addr=/ip4/0.0.0.0/tcp/30333 \
  --base-path $HOME/data/relay \
  --chain=kusama \
  --execution=wasm
```

</TabItem>
<TabItem value="Docker">

```bash=
docker run -p 127.0.0.1:9933:9933 -v ~/data:/data \
    kiltprotocol/kilt-node:latest \
    --rpc-port=9933 \
    --rpc-cors=all \
    --rpc-methods=unsafe \
    --chain=spiritnet \
    --runtime=spiritnet \
    --execution=wasm \
    --listen-addr=/ip4/0.0.0.0/tcp/30336 \
    --name "name of collator" \
    --base-path /data/parachain \
    --keystore-path /data/keystore \
    --collator \
    -- \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --base-path /data/relay \
    --chain=kusama \
    --execution=wasm
```

</TabItem>
</Tabs>

## Troubleshooting

There are a few things that you can check to make sure everything is setup correctly.

0. Check that your node is fully synced with the relaychain & parachain. (best and finalised block number is equal to the one shown in the polkadot apps & on subscan)
1. Check that you are a selected collator. Your address should be listed in `parachainStaking > topCandidates()`
2. The `parachainStaking` pallet will register your address in the session pallet. Check that your address is listed in `session > validators()`
3. Check that session keys are associated with your validatorId (aka AccountId). There should be a 32 Byte long public key stored in `session > nextKeys(your AccountId)`
4. Your node will only collate if it has the corresponding private key of the public key . Connect to your node and check with `author > hasKey(<pubKey from 3.>, aura)` if your node has the private key.
5. If your logs print the message that starts with a :gift: emoji you can skip steps 1-4 since your collator is building blocks. But they might not get included by the relay chain.
6. Check in the Polkadot Apps under `network > explorer` that your accountId is shown next to a block. You can be 100% sure that you produce blocks if you are listed there. If steps 1-5 all look fine for your collator but you don't see your blocks, you might not produce and send blocks fast enough. This can be caused by slow hardware or a slow internet connection. Also, note that a high bandwidth connection can still be slow if it has a high ping! Bandwidth != latency
