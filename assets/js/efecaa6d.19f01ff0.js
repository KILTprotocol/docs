(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5074],{5380:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5380,e.exports=t},1909:(e,t,n)=>{"use strict";n.d(t,{Z:()=>u});var i=n(7462),o=n(7294),a=n(2263),s=n(3945),r=n(8182),c=n(2175),l=n(4866),d=n(5162),p=n(814);const u=e=>{let{children:t,fileName:n,...u}=e;const h=t,{code:b}=(0,c.transform)(h,{plugins:["transform-typescript"],retainLines:!0}),{siteConfig:{customFields:{prettierConfig:m}}}=(0,a.Z)(),k=(0,s.format)(b,{parser:r.parsers.babel.parse,...m}),C=n?`${n}.ts`:void 0,f=n?`${n}.js`:void 0;return o.createElement(l.Z,{groupId:"ts-js-choice"},o.createElement(d.Z,{value:"ts",label:"Typescript",default:!0},o.createElement(p.Z,(0,i.Z)({},u,{className:"language-ts",title:C}),h)),o.createElement(d.Z,{value:"js",label:"Javascript"},o.createElement(p.Z,(0,i.Z)({},u,{className:"language-js",title:f}),k)))}},7253:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>u,contentTitle:()=>d,default:()=>k,frontMatter:()=>l,metadata:()=>p,toc:()=>h});var i=n(7462),o=(n(7294),n(3905)),a=n(1909);const s="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport async function createNftCollectionCType(\n  creator: Kilt.DidUri,\n  submitterAccount: Kilt.KiltKeyringPair,\n  signCallback: Kilt.SignExtrinsicCallback\n): Promise<Kilt.ICType> {\n  const api = Kilt.ConfigService.get('api')\n\n  // Create a new CType definition.\n  const ctype = Kilt.CType.fromProperties(\n    `NFT Collection Certification CType by ${creator}`,\n    {\n      name: {\n        type: 'string'\n      },\n      pieces: {\n        type: 'integer'\n      },\n      creationDate: {\n        type: 'string'\n      },\n      artistIdentity: {\n        type: 'string'\n      }\n    }\n  )\n\n  // Generate a creation tx.\n  const encodedCtype = Kilt.CType.toChain(ctype)\n  const ctypeCreationTx = api.tx.ctype.add(encodedCtype)\n  // Sign it with the right DID key.\n  const authorizedCtypeCreationTx = await Kilt.Did.authorizeTx(\n    creator,\n    ctypeCreationTx,\n    signCallback,\n    submitterAccount.address\n  )\n  // Submit the creation tx to the KILT blockchain\n  // using the KILT account specified in the creation operation.\n  await Kilt.Blockchain.signAndSubmitTx(\n    authorizedCtypeCreationTx,\n    submitterAccount\n  )\n\n  return ctype\n}\n",r="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport function createNftCollectionCredential(\n  ctype: Kilt.ICType,\n  assetDid: Kilt.AssetDidUri,\n  artistDid: Kilt.DidUri\n): Kilt.IPublicCredentialInput {\n  const claimProperties: Kilt.IClaimContents = {\n    name: 'Awesome NFT drop',\n    // NFT collection only has 100 pieces in total\n    pieces: 100,\n    // NFT collection was released on Jan 1st, 2023\n    creationDate: new Date(2023, 0, 1).toISOString(),\n    artistIdentity: artistDid\n  }\n  const fullClaim: Kilt.IAssetClaim = {\n    contents: claimProperties,\n    cTypeHash: Kilt.CType.idToHash(ctype.$id),\n    subject: assetDid\n  }\n\n  return Kilt.PublicCredential.fromClaim(fullClaim)\n}\n",c="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport async function issueCredential(\n  attester: Kilt.DidUri,\n  submitterAccount: Kilt.KiltKeyringPair,\n  signCallback: Kilt.SignExtrinsicCallback,\n  credential: Kilt.IPublicCredentialInput\n): Promise<void> {\n  const api = Kilt.ConfigService.get('api')\n\n  const credentialCreationTx = api.tx.publicCredentials.add(\n    Kilt.PublicCredential.toChain(credential)\n  )\n\n  // Same as for traditional KILT credentials\n  const authorizedAttestationTx = await Kilt.Did.authorizeTx(\n    attester,\n    credentialCreationTx,\n    signCallback,\n    submitterAccount.address\n  )\n  await Kilt.Blockchain.signAndSubmitTx(\n    authorizedAttestationTx,\n    submitterAccount\n  )\n}\n",l={id:"public-credential-issuance",title:"Credential Issuance"},d=void 0,p={unversionedId:"develop/sdk/cookbook/public_credentials/public-credential-issuance",id:"develop/sdk/cookbook/public_credentials/public-credential-issuance",title:"Credential Issuance",description:"As for traditional KILT credentials, public credentials also have their structure defined by a CType, although CTypes that can be used to represent information about assets would probably differ from the ones used to represent information about people.",source:"@site/docs/develop/01_sdk/02_cookbook/05_public_credentials/01_credential_issuance.md",sourceDirName:"develop/01_sdk/02_cookbook/05_public_credentials",slug:"/develop/sdk/cookbook/public_credentials/public-credential-issuance",permalink:"/docs/develop/sdk/cookbook/public_credentials/public-credential-issuance",draft:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/05_public_credentials/01_credential_issuance.md",tags:[],version:"current",lastUpdatedAt:1687444875,formattedLastUpdatedAt:"Jun 22, 2023",sidebarPosition:1,frontMatter:{id:"public-credential-issuance",title:"Credential Issuance"},sidebar:"sdk",previous:{title:"Revoke a Credential",permalink:"/docs/develop/sdk/cookbook/claiming/attestation-removal"},next:{title:"Retrieve Public Credentials",permalink:"/docs/develop/sdk/cookbook/public_credentials/public-credential-retrieval"}},u={},h=[{value:"Create and Issue the Credential",id:"create-and-issue-the-credential",level:2}],b={toc:h},m="wrapper";function k(e){let{components:t,...n}=e;return(0,o.kt)(m,(0,i.Z)({},b,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"As for traditional KILT credentials, public credentials also have their structure defined by a ",(0,o.kt)("a",{parentName:"p",href:"/docs/concepts/credentials/ctypes"},"CType"),", although CTypes that can be used to represent information about assets would probably differ from the ones used to represent information about people."),(0,o.kt)("p",null,"As mentioned in the section about credentials, the creation of a CType in KILT involves two steps: the definition of a CType and the anchoring of its hash on the KILT blockchain."),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The creator of a CType is required to have a full DID with an attestation key.\nTo see how to manage DIDs, please refer to the ",(0,o.kt)("a",{parentName:"p",href:"/docs/develop/sdk/cookbook/dids/full-did-update"},"DID section"),".")),(0,o.kt)("p",null,"The following snippets show how to create a CType:"),(0,o.kt)(a.Z,{mdxType:"TsJsBlock"},s),(0,o.kt)("h2",{id:"create-and-issue-the-credential"},"Create and Issue the Credential"),(0,o.kt)("p",null,"With the new CType written to the chain, the new public credential object can be created with the actual content, and then written to the chain for the rest of the KILT users (and beyond) to consume."),(0,o.kt)("p",null,"Creating a public credential is as simple as creating an object that conforms to the required structure of the CType:"),(0,o.kt)(a.Z,{mdxType:"TsJsBlock"},r),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"The creation of the credential object does not require any interaction with the blockchain per se.\nThis also means that, until the object is written to the blockchain (see below), it cannot be used/retrieved/verified by anyone else, so it is, by all means, not existing.")),(0,o.kt)("p",null,"Once the credential object is created, it must be written to the blockchain for other people to be able to use it."),(0,o.kt)(a.Z,{mdxType:"TsJsBlock"},c),(0,o.kt)("admonition",{title:"Credential has to be CBOR-encoded!",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Given a public credential object, the SDK internally CBOR-encodes it before firing the extrinsic to the blockchain!\nThis is to save space on credentials that actually benefit from CBOR compression (e.g., if they contain a lot of binary information).\nHence, creating public credentials without the SDK requires the credential to be CBOR-encoded!")))}k.isMDXComponent=!0}}]);