(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8936],{5380:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5380,e.exports=t},6793:(e,t,n)=>{"use strict";n.d(t,{Z:()=>r});var i=n(7294),s=n(814);const r=e=>{let{children:t,funcName:n="main",funcEnd:r="}",snippets:a,leadingSpaces:o=2,...l}=e;const c=t.split(/\r?\n/);let d="";if(a)d=JSON.parse(a).map((e=>Array.isArray(e)?c.slice(e[0],e[1]).map((e=>e.slice(o))).join("\n"):e)).join("\n");else if(n){let e,t;for(let i=0;i<c.length;i++)if(c[i].includes(n)){if(e=i,c[i].includes(" {"))break}else if(c[i].includes(" {")&&void 0!==e){e=i;break}for(let n=c.length-1;n>0;n--)if(c[n].includes(r)){t=n;break}d=c.slice(e+1,t).map((e=>e.slice(o))).join("\n")}return i.createElement(s.Z,l,d)}},1909:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var i=n(7462),s=n(7294),r=n(2263),a=n(3945),o=n(8182),l=n(2175),c=n(4866),d=n(5162),p=n(814);const h=e=>{let{children:t,fileName:n,...h}=e;const u=t,{code:m}=(0,l.transform)(u,{plugins:["transform-typescript"],retainLines:!0}),{siteConfig:{customFields:{prettierConfig:f}}}=(0,r.Z)(),y=(0,a.format)(m,{parser:o.parsers.babel.parse,...f}),g=n?`${n}.ts`:void 0,v=n?`${n}.js`:void 0;return s.createElement(c.Z,{groupId:"ts-js-choice"},s.createElement(d.Z,{value:"ts",label:"Typescript",default:!0},s.createElement(p.Z,(0,i.Z)({},h,{className:"language-ts",title:g}),u)),s.createElement(d.Z,{value:"js",label:"Javascript"},s.createElement(p.Z,(0,i.Z)({},h,{className:"language-js",title:v}),y)))}},9747:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var i=n(7462),s=n(7294),r=n(2263),a=n(3945),o=n(8182),l=n(2175),c=n(4866),d=n(5162),p=n(6793);const h=e=>{let{children:t,fileName:n,...h}=e;const u=t,{code:m}=(0,l.transform)(u,{plugins:["transform-typescript"],retainLines:!0}),{siteConfig:{customFields:{prettierConfig:f}}}=(0,r.Z)(),y=(0,a.format)(m,{parser:o.parsers.babel.parse,...f}),g=n?`${n}.ts`:void 0,v=n?`${n}.js`:void 0;return s.createElement(c.Z,{groupId:"ts-js-choice"},s.createElement(d.Z,{value:"ts",label:"Typescript",default:!0},s.createElement(p.Z,(0,i.Z)({},h,{className:"language-ts",title:g}),u)),s.createElement(d.Z,{value:"js",label:"Javascript"},s.createElement(p.Z,(0,i.Z)({},h,{className:"language-js",title:v}),y)))}},2656:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>f,contentTitle:()=>u,default:()=>b,frontMatter:()=>h,metadata:()=>m,toc:()=>y});var i=n(7462),s=(n(7294),n(3905)),r=n(9747),a=n(1909);const o="/* eslint-disable @typescript-eslint/no-unused-vars */\nimport * as Kilt from '@kiltprotocol/sdk-js'\n\nexport function main() {\n  const emailCType: Kilt.ICType = {\n    $id: 'kilt:ctype:0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac',\n    $schema: 'http://kilt-protocol.org/draft-01/ctype#',\n    title: 'Email',\n    properties: {\n      Email: {\n        type: 'string'\n      }\n    },\n    type: 'object'\n  }\n}\n",l="import { randomAsHex } from '@polkadot/util-crypto'\n\n// Store somewhere in the backend.\nexport function generateRequestChallenge() {\n  return randomAsHex(24)\n}\n",c="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport interface Param {\n  verifierDidUri: Kilt.DidUri\n  session: {\n    encryptionKeyUri: Kilt.DidResourceUri\n  }\n  requestChallenge: string\n}\n\nexport function main({ verifierDidUri, session, requestChallenge }: Param): {\n  message: Kilt.IMessage\n} {\n  // The `session` was created earlier in your frontend. Only the session DID URI is sent to your backend.\n  const { did: claimerSessionDidUri } = Kilt.Did.parse(session.encryptionKeyUri)\n\n  // The message is constructed in your backend\n  const message = Kilt.Message.fromBody(\n    {\n      content: {\n        cTypes: [\n          {\n            // the hash of the email CType\n            cTypeHash:\n              '0x3291bb126e33b4862d421bfaa1d2f272e6cdfc4f96658988fbcffea8914bd9ac',\n            requiredProperties: ['Email']\n          }\n        ],\n        challenge: requestChallenge\n      },\n      type: 'request-credential'\n    },\n    verifierDidUri,\n    claimerSessionDidUri\n  )\n\n  return { message }\n}\n",d="import * as Kilt from '@kiltprotocol/sdk-js'\n\nexport interface Param {\n  message: Kilt.IMessage\n  verifierDidUri: Kilt.DidUri\n  verifierKeys: {\n    authentication: Kilt.KiltKeyringPair\n    encryption: Kilt.KiltEncryptionKeypair\n    attestation: Kilt.KiltKeyringPair\n    delegation: Kilt.KiltKeyringPair\n  }\n  session: {\n    encryptionKeyUri: Kilt.DidResourceUri\n    send: (message: Kilt.IEncryptedMessage) => Promise<void>\n  }\n}\n\nexport async function main({\n  message,\n  verifierDidUri,\n  verifierKeys,\n  session\n}: Param) {\n  const { document: verifierDidDoc } = await Kilt.Did.resolve(verifierDidUri)\n  if (!verifierDidDoc) {\n    throw new Error('The verifier DID must exist')\n  }\n  const verifierEncryptionKey = verifierDidDoc.keyAgreement?.[0]\n  if (!verifierEncryptionKey) {\n    throw new Error('The verifier DID must have a key agreement key')\n  }\n\n  // Create a callback that uses the DID encryption key to encrypt the message.\n  const encryptCallback: Kilt.EncryptCallback = async ({\n    data,\n    peerPublicKey\n  }) => {\n    const { box, nonce } = Kilt.Utils.Crypto.encryptAsymmetric(\n      data,\n      peerPublicKey,\n      verifierKeys.encryption.secretKey\n    )\n    return {\n      data: box,\n      nonce,\n      keyUri: `${verifierDidDoc.uri}${verifierEncryptionKey.id}`\n    }\n  }\n\n  const encryptedMessage = await Kilt.Message.encrypt(\n    message,\n    encryptCallback,\n    session.encryptionKeyUri\n  )\n\n  // Finally, send the encrypted message to the extension.\n  // While the above code will be executed on the server, this must happen in\n  // the frontend since it's dispatching the message to the browser extension.\n  await session.send(encryptedMessage)\n}\n",p="import '@kiltprotocol/augment-api'\nimport * as Kilt from '@kiltprotocol/sdk-js'\n\ntype ListenCallback = (message: Kilt.IEncryptedMessage) => Promise<void>\n\nexport interface Param {\n  session: { listen: (call: ListenCallback) => ReturnType<ListenCallback> }\n  verifierKeys: {\n    authentication: Kilt.KiltKeyringPair\n    encryption: Kilt.KiltEncryptionKeypair\n    attestation: Kilt.KiltKeyringPair\n    delegation: Kilt.KiltKeyringPair\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nfunction isTrustedAttester(_attester: Kilt.DidUri): boolean {\n  return true\n}\n\nexport async function main({ session, verifierKeys }: Param) {\n  async function processInBackend(message: Kilt.IEncryptedMessage) {\n    // Create a callback that uses the DID encryption key to decrypt the message.\n    const decryptCallback: Kilt.DecryptCallback = async ({\n      data,\n      nonce,\n      peerPublicKey\n    }) => {\n      const result = Kilt.Utils.Crypto.decryptAsymmetric(\n        { box: data, nonce },\n        peerPublicKey,\n        verifierKeys.encryption.secretKey\n      )\n      if (!result) {\n        throw new Error('Cannot decrypt')\n      }\n      return {\n        data: result\n      }\n    }\n\n    const decryptedMessage = await Kilt.Message.decrypt(\n      message,\n      decryptCallback\n    )\n\n    if (decryptedMessage.body.type !== 'submit-credential') {\n      throw new Error('Unexpected message type')\n    }\n    const credential = decryptedMessage.body.content[0]\n\n    const { revoked, attester } = await Kilt.Credential.verifyPresentation(\n      credential\n    )\n\n    if (revoked) {\n      throw new Error(\"Credential has been revoked and hence it's not valid.\")\n    }\n    if (isTrustedAttester(attester)) {\n      console.log(\n        \"The claim is valid. Claimer's email:\",\n        credential.claim.contents.Email\n      )\n    }\n  }\n\n  // In the frontend we wait for messages from the browser extension and forward them to the server.\n  await session.listen(async (message: Kilt.IEncryptedMessage) => {\n    processInBackend(message)\n  })\n}\n",h={id:"dapp-verifier",title:"Verifying a Credential"},u=void 0,m={unversionedId:"develop/dApp/dapp-verifier",id:"develop/dApp/dapp-verifier",title:"Verifying a Credential",description:"This section demonstrates how to build a basic verifier according to the Credential API Specification.",source:"@site/docs/develop/07_dApp/04_verifier.md",sourceDirName:"develop/07_dApp",slug:"/develop/dApp/dapp-verifier",permalink:"/docs/develop/dApp/dapp-verifier",draft:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/07_dApp/04_verifier.md",tags:[],version:"current",lastUpdatedAt:1690443949,formattedLastUpdatedAt:"Jul 27, 2023",sidebarPosition:4,frontMatter:{id:"dapp-verifier",title:"Verifying a Credential"},sidebar:"dApp",previous:{title:"Setting Up the Communication Session",permalink:"/docs/develop/dApp/session"}},f={},y=[{value:"Request a Credential Presentation",id:"request-a-credential-presentation",level:2},{value:"Verify the Presentation",id:"verify-the-presentation",level:2}],g={toc:y},v="wrapper";function b(e){let{components:t,...n}=e;return(0,s.kt)(v,(0,i.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"This section demonstrates how to build a basic verifier according to the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/KILTprotocol/spec-ext-credential-api"},"Credential API Specification"),".\nBefore continuing, please make sure you have already set up the ",(0,s.kt)("a",{parentName:"p",href:"/docs/develop/dApp/session"},"communication session")," and ",(0,s.kt)("a",{parentName:"p",href:"/docs/develop/dApp/well-known-did-config"},"Well-Known DID Configuration"),"."),(0,s.kt)("p",null,"This guide explains specifically how a web server can request a credential presentation from one of its visitors (the claimer).\nAfter the browser extension verified the Well-Known DID Configuration and the encrypted communication channel between the extension and the server was established, the web server can request the credential presentation.\nThis is a two step process."),(0,s.kt)("p",null,"First the server sends a message to the extension that request the presentation of a credential.\nSince we don't want to see just any credential, but expect specific content, we also require that the credential conforms to a specific ",(0,s.kt)("a",{parentName:"p",href:"/docs/concepts/credentials/ctypes"},"CType"),".\nWhen the extension receives the request, it will prompt the user to select a credential that should be presented to the server.\nThe user can also choose to reject this request and not to show any presentation."),(0,s.kt)("p",null,"The second step is to verify the received credential.\nAfter the user chooses the credential, the extension will pass a response to the website which contains the credential presentation.\nThe server of that website needs to ensure that this presentation is actually valid."),(0,s.kt)("h2",{id:"request-a-credential-presentation"},"Request a Credential Presentation"),(0,s.kt)("p",null,"Before the website can request a credential, it needs the type of credential (CType) that it wants to request.\nIn this guide the website requests an email address that is owned by the DID.\nFor that it uses the Email CType.\nYou can search through existing CTypes in the ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/KILTprotocol/ctype-index"},"CType Index"),"."),(0,s.kt)(r.Z,{mdxType:"TsJsSnippet"},o),(0,s.kt)("p",null,"After settled on a CType, the server can build the request for the visitor.\nSince we want to ensure that the presentation of the credential is fresh, the server first has to create a random challenge.\nThe presentation must include this challenge and since it's random, the presentation must be created and signed from scratch.\nThis ensures that it's not possible to record a presentation and just send this, pretending to be the owner of the DID.\nThe challenge can be generated using the polkadot crypto utilities:"),(0,s.kt)(a.Z,{mdxType:"TsJsBlock"},l),(0,s.kt)("p",null,"With the challenge the server can construct the ",(0,s.kt)("inlineCode",{parentName:"p"},"request-credential")," message.\nThe request is sent to the light DID (",(0,s.kt)("inlineCode",{parentName:"p"},"claimerSessionDid"),") that is used to encrypt the messages (see ",(0,s.kt)("a",{parentName:"p",href:"/docs/develop/dApp/session"},"Session")," for more information)."),(0,s.kt)(r.Z,{funcEnd:"return",mdxType:"TsJsSnippet"},c),(0,s.kt)("admonition",{title:"Privacy",type:"note"},(0,s.kt)("p",{parentName:"admonition"},"The credential itself doesn't need to be issued to this DID since the light DID is only used to encrypt the messages.\nWe don't use the full DID of the claimer to establish the encrypted communication, so that the claimer first can ensure the origin of the ",(0,s.kt)("inlineCode",{parentName:"p"},"request-credential")," message.")),(0,s.kt)("p",null,"After the server has built the message object, it must encrypt the message for the claimer.\nOnce the message is encrypted the server can pass on the message to the extension."),(0,s.kt)(r.Z,{mdxType:"TsJsSnippet"},d),(0,s.kt)("h2",{id:"verify-the-presentation"},"Verify the Presentation"),(0,s.kt)("p",null,"After sending the ",(0,s.kt)("inlineCode",{parentName:"p"},"request-credential")," message to the extension, the verifier listens for a message of type ",(0,s.kt)("inlineCode",{parentName:"p"},"submit-credential")," in response."),(0,s.kt)("p",null,"After the response from the extension is received, forwarded to the server and decrypted, the verifier must check that it has the expected CType and that it contains a valid credential.\nSince everyone can run an attestation service, you need to make sure that you also verify that the attester is trusted."),(0,s.kt)(r.Z,{mdxType:"TsJsSnippet"},p),(0,s.kt)("p",null,"That's it! Your verifier has successfully requested and verified a credential."))}b.isMDXComponent=!0}}]);