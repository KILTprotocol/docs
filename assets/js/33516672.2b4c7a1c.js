(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[464],{5764:e=>{function i(e){var i=new Error("Cannot find module '"+e+"'");throw i.code="MODULE_NOT_FOUND",i}i.keys=()=>[],i.resolve=i,i.id=5764,e.exports=i},9293:(e,i,t)=>{"use strict";t.r(i),t.d(i,{assets:()=>c,contentTitle:()=>d,default:()=>p,frontMatter:()=>s,metadata:()=>l,toc:()=>u});var n=t(4848),o=t(8453),a=t(3172);const r="import * as Kilt from '@kiltprotocol/sdk-js'\n\ntype KeyLookup = (parameter: {\n  didUri: Kilt.DidUri\n  keyRelationship: Kilt.VerificationKeyRelationship\n}) => Promise<{\n  key: Kilt.KiltKeyringPair\n  keyType: Kilt.VerificationKeyType\n  keyUri: Kilt.DidResourceUri\n}>\n\nexport async function generateAndVerifyDidAuthenticationSignature(\n  did: Kilt.DidDocument,\n  payload: Uint8Array,\n  keyLookup: KeyLookup\n): Promise<void> {\n  // How the key is looked up depends on where the key is stored (e.g. memory, hardware wallet, browser extension)\n  const { key, keyUri } = await keyLookup({\n    didUri: did.uri,\n    keyRelationship: 'authentication'\n  })\n\n  // Generate a signature using the key that we just looked up.\n  const signature = key.sign(payload)\n\n  // Print the generated signature object.\n  console.log('Generated signature:')\n  console.log(Kilt.Utils.Crypto.u8aToHex(signature))\n\n  // Verify the validity of the signature using the DID's authentication public key.\n  // It throws if the signature cannot be verified.\n  await Kilt.Did.verifyDidSignature({\n    message: payload,\n    signature,\n    keyUri,\n    expectedVerificationMethod: 'authentication'\n  })\n}\n",s={id:"did-signature",title:"Generate and Verify a DID Signature"},d=void 0,l={id:"develop/sdk/cookbook/dids/did-signature",title:"Generate and Verify a DID Signature",description:"In addition to being used to authorize chain operations, both light and full DIDs have off-chain applications.",source:"@site/docs/develop/01_sdk/02_cookbook/01_dids/07_did_signature.md",sourceDirName:"develop/01_sdk/02_cookbook/01_dids",slug:"/develop/sdk/cookbook/dids/did-signature",permalink:"/docs/develop/sdk/cookbook/dids/did-signature",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/01_dids/07_did_signature.md",tags:[],version:"current",lastUpdatedAt:172198217e4,sidebarPosition:7,frontMatter:{id:"did-signature",title:"Generate and Verify a DID Signature"},sidebar:"sdk",previous:{title:"Build DID Extrinsics",permalink:"/docs/develop/sdk/cookbook/dids/full-did-batch"},next:{title:"Exporting a KILT DID",permalink:"/docs/develop/sdk/cookbook/dids/did-export"}},c={},u=[];function h(e){const i={admonition:"admonition",code:"code",p:"p",...(0,o.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i.p,{children:"In addition to being used to authorize chain operations, both light and full DIDs have off-chain applications."}),"\n",(0,n.jsx)(i.p,{children:"One such applications is generating digital signatures.\nAs a DID can have multiple keys, in addition to the signature data itself, a DID signature contains information about the signer's DID and key used, so that Verifiers have all the information needed to resolve the DID from the KILT blockchain and use the right key to verify the generated signature."}),"\n",(0,n.jsx)(i.p,{children:"The snippet below shows how to generate and verify a DID signature using the KILT SDK."}),"\n",(0,n.jsx)(a.A,{children:r}),"\n",(0,n.jsx)(i.admonition,{type:"note",children:(0,n.jsxs)(i.p,{children:["Notice that the snippet above takes a ",(0,n.jsx)(i.code,{children:"DidDocument"})," instance to generate the signature.\nA ",(0,n.jsx)(i.code,{children:"DidDocument"})," can represent either a light or a full DID.\nThis means that both light and full DIDs can generate signatures, and the KILT SDK implements the right verification logic depending on whether the signer is a light or a full DID."]})})]})}function p(e={}){const{wrapper:i}={...(0,o.R)(),...e.components};return i?(0,n.jsx)(i,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},3172:(e,i,t)=>{"use strict";t.d(i,{A:()=>p});var n=t(6540),o=t(4586),a=t(6352),r=t(8463),s=t(5283),d=t(6745),l=t(1470),c=t(9365),u=t(1432),h=t(4848);const p=e=>{let{children:i,fileName:t,...p}=e;const g=i,[f,k]=(0,n.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:m}}}=(0,o.A)(),D=(0,n.useMemo)((()=>{const{code:e}=(0,a.transform)(g,{plugins:["transform-typescript"],retainLines:!0}),i=["./generateAccount","./generateKeypairs","./ctypeSchema","./createClaim","./generateLightDid","../attester/ctypeSchema","../claimer/generateLightDid","../claimer/generateCredential","./claimer/createPresentation","./claimer/generateKeypairs","./claimer/generateLightDid"];let t=e.replace(/from\s+['"](.+)['"]/g,((e,t)=>i.includes(t)?`from '${t}.js'`:e));return t=t.replace("if (require.main === module)","if (process.argv[1] === new URL(import.meta.url).pathname)"),t}),[g]);(0,n.useEffect)((()=>{r.GP(D,{parser:"babel",plugins:[s.A,d.Ay],...m}).then(k)}),[m,D]);const y=[{fileName:t?`${t}.ts`:void 0,fileContents:g,fileID:"ts",fileLabel:"Typescript"},{fileName:t?`${t}.js`:void 0,fileContents:f,fileID:"js",fileLabel:"Javascript"}];return(0,h.jsx)(h.Fragment,{children:(0,h.jsx)(l.A,{groupId:"ts-js-choice",children:y.map((e=>(0,h.jsx)(c.A,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,h.jsx)(u.A,{...p,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);