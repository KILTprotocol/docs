(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[241],{5380:e=>{function t(e){var t=new Error("Cannot find module '"+e+"'");throw t.code="MODULE_NOT_FOUND",t}t.keys=()=>[],t.resolve=t,t.id=5380,e.exports=t},5991:(e,t,n)=>{"use strict";n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>p});var i=n(5893),o=n(1151),r=n(1909);const s="import * as Kilt from '@kiltprotocol/sdk-js'\n\nimport { mnemonicGenerate } from '@polkadot/util-crypto'\n\nexport function generateKeypairs(mnemonic = mnemonicGenerate()): {\n  authentication: Kilt.KiltKeyringPair\n  keyAgreement: Kilt.KiltEncryptionKeypair\n  assertionMethod: Kilt.KiltKeyringPair\n  capabilityDelegation: Kilt.KiltKeyringPair\n} {\n  const authentication = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const assertionMethod = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const capabilityDelegation = Kilt.Utils.Crypto.makeKeypairFromUri(mnemonic)\n\n  const keyAgreement = Kilt.Utils.Crypto.makeEncryptionKeypairFromSeed(\n    Kilt.Utils.Crypto.mnemonicToMiniSecret(mnemonic)\n  )\n\n  return {\n    authentication: authentication,\n    keyAgreement: keyAgreement,\n    assertionMethod: assertionMethod,\n    capabilityDelegation: capabilityDelegation\n  }\n}\n",a={id:"key-generation",title:"Generate DID keys"},d=void 0,l={id:"develop/sdk/cookbook/dids/key-generation",title:"Generate DID keys",description:"Creating a Decentralized Identifier (DID) in the KILT network involves generating keying material for authentication and encryption.",source:"@site/docs/develop/01_sdk/02_cookbook/01_dids/00_generate_keys.md",sourceDirName:"develop/01_sdk/02_cookbook/01_dids",slug:"/develop/sdk/cookbook/dids/key-generation",permalink:"/docs/develop/sdk/cookbook/dids/key-generation",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/01_dids/00_generate_keys.md",tags:[],version:"current",lastUpdatedAt:1707216207,formattedLastUpdatedAt:"Feb 6, 2024",sidebarPosition:0,frontMatter:{id:"key-generation",title:"Generate DID keys"},sidebar:"sdk",previous:{title:"Quickstart",permalink:"/docs/develop/sdk/quickstart"},next:{title:"Create a Light DID",permalink:"/docs/develop/sdk/cookbook/dids/light-did-creation"}},c={},p=[];function m(e){const t={admonition:"admonition",code:"code",p:"p",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Creating a Decentralized Identifier (DID) in the KILT network involves generating keying material for authentication and encryption.\nIn this guide, we'll demonstrate how to create a set of key pairs suitable for generating a KILT DID."}),"\n",(0,i.jsxs)(t.p,{children:["Before we proceed, it's important to note that this example assumes the usage of the ",(0,i.jsx)(t.code,{children:"@kiltprotocol/sdk-js"})," library along with the ",(0,i.jsx)(t.code,{children:"@polkadot/util-crypto"})," library for cryptographic operations.\nAdditionally, we want to emphasize the significance of securely storing keys and the mnemonic seed phrase.\nFor production use, ensure that private keys are encrypted and stored safely, while also creating a backup of the mnemonic seed phrase."]}),"\n",(0,i.jsx)(t.p,{children:"In the example provided, we derive different types of keys from a single account using derivation paths.\nThis approach allows us to generate various key pairs for authentication, key agreement, assertion methods, and capability delegation from one mnemonic seed phrase.\nUsing derivation paths simplifies key management, ensuring that a single mnemonic seed serves as the basis for multiple keys associated with a DID.\nThis method improves efficiency while maintaining security.\nHowever, it's essential to handle and store private keys securely to prevent unauthorized access and ensure the overall integrity and privacy of the decentralized identity system."}),"\n",(0,i.jsx)(t.p,{children:"Below is an example code snippet illustrating the key pair generation for a KILT DID:"}),"\n",(0,i.jsx)(r.Z,{children:s}),"\n",(0,i.jsx)(t.admonition,{type:"info",children:(0,i.jsx)(t.p,{children:"This example doesn't show how to store the keys.\nIt is recommended to store the keys in a secure manner, e.g. only storing the private keys encrypted on disk.\nThe mnemonic seed phrase can be used to regenerate the keys, so it is recommended to also store the mnemonic in a secure manner and create a backup of it."})})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(m,{...e})}):m(e)}},1909:(e,t,n)=>{"use strict";n.d(t,{Z:()=>h});var i=n(7294),o=n(2263),r=n(2175),s=n(4935),a=n(4990),d=n(9966),l=n(4866),c=n(5162),p=n(9286),m=n(5893);const h=e=>{let{children:t,fileName:n,...h}=e;const k=t,[y,u]=(0,i.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:g}}}=(0,o.Z)(),f=(0,i.useMemo)((()=>{const{code:e}=(0,r.transform)(k,{plugins:["transform-typescript"],retainLines:!0});return e}),[k]);(0,i.useEffect)((()=>{s.WU(f,{parser:"babel",plugins:[a.Z,d.ZP],...g}).then(u)}),[g,f]);const v=[{fileName:n?`${n}.ts`:void 0,fileContents:k,fileID:"ts",fileLabel:"Typescript"},{fileName:n?`${n}.js`:void 0,fileContents:y,fileID:"js",fileLabel:"Javascript"}];return(0,m.jsx)(m.Fragment,{children:(0,m.jsx)(l.Z,{groupId:"ts-js-choice",children:v.map((e=>(0,m.jsx)(c.Z,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,m.jsx)(p.Z,{...h,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);