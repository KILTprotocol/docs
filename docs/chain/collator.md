---
id: collator
title: Become a Collator
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';


We will guide you through the steps to become a collator.
First we will discuss the hardware requirements and how you could test your performance.
After that we go over a few configurations options and show you how to start a collator.
When your collator is running you still need to register on chain.
We will show you how to obtain your session keys and become a collator candidate.

## Hardware Requirements

The following hardware was used to benchmark the KILT blockchain and calculate the extrinsic weights.
Your hardware should at least be as fast as the hardware used for benchmarking.
Having a fast storage is important for the overall performance.

- OS - Ubuntu 20.04.2
- CPU - AMD Ryzen 7 1700X
- Storage - A NVMe solid-state drive. Should be reasonably sized to deal with blockchain growth. Starting around 80GB - 160GB will be okay for the first six months of KILT's parachain and Kusama relay chain but will need to be re-evaluated every six months.
- Memory - 16GB

The specification posted above are by no means the minimum specs that you could use when running a Collator, however you should be aware that if you are using less you may need to toggle some extra optimizations in order to be equal to other Collator that are running the standard.

You can compare your hardware with the above listed hardware by running the benchmarks.
If your benchmark results are better (smaller weights) than ours, your hardware is faster than the required minimum.
The results of the spiritnet benchmarks can be found [here](https://github.com/KILTprotocol/mashnet-node/tree/develop/runtimes/spiritnet/src/weights).
You can find [a guide on how to run benchmarks](#Benchmarking-(optional)) further below.

## Start a Node

There are several ways to build and test a collator node.
**These commands are based on commits.**
The time needed to start a node depends on the method chosen.
We will go through how to use a Docker image or compile directly from our mashnet-node repository.
There are currently two different runtimes that can be executed.

- The `peregrine` chain will be matching the closest to our final chain and contains all the KILT functionality that is currently available.
- The `spiritnet` chain will be the actual network after launch and contains only stable features

Each has their own benchmarks to track the weight of transactions of the given networks.

### Configuration

When we run our collator we need pass a few configurations.
Some of the parameters might appear twice in the command that start the collator.
The reason for that is, that the collator actually executes two blockchain nodes.
The parameter that are listed before the `--` are related to the parachain node (the KILT blockchain), whereas the parameters following the `--` are passed to the relaychain.

In the following we will explain a small selection of parameters.

#### RPC Endpoint

Our collator needs session keys that connect your collator with your KILT account id.
These session keys can be generated by calling an RPC endpoint that your collator optionally exposes.
Exposing the RPC endpoints can be done using the following parameters:

```
--rpc-port=9933
--rpc-cors=all
--rpc-methods=unsafe
```

With these parameters you can make RPCalls directly using curl.
But you won't be able to connect with the polkadot apps.
The polkadot apps try to connect to your node via a Websocket connection.
You can use the following arguments for exposing the Websocket endpoint:

```
--ws-port=9944
--rpc-methods=unsafe
```

If you want to connect from a remote host to your RPC endpoints (e.g. using the polkadot apps) you will need to expose the rpc endpoints.
This can be done using the following arguments:

```
--ws-external
--unsafe-rpc-external
```

:::danger

Be aware that this might **expose your collator**!
You should be the only one that is able to call the RPC endpoints.

:::

#### Execution Wasm

We pass the `--execution=wasm` parameter to both the relaychain and parachain since we don't want the faster native execution.
The native execution might be faster but can also derive from the WASM execution and result in a different state.
When this happens your collator will crash.
Since the WASM is the single truth all collators should execute the WASM version of the state transition function.

#### Select which runtime and chain to use

The `--chain` parameter decides which blockchain we want to execute.
We need to pass this parameter to the parachain and the relaychain, since both chains are separate blockchains.
The parachain accepts an additional runtime parameter that selects which runtime is executed and decides which execution environment is used.
This can either be `peregrine` or `spiritnet`.
For now this parameter isn't required, since both runtimes are very similar and can run in the same environment, but it is safer to provided it already now.

#### Where are all the files stored?

The `--base-path` parameter configures where all the persistent files are written.
By default the session keys will also be stored int he *base path*, but we recommend to separate them from the other files.
This makes sure that the keyfiles are not accidentally lost or published when you backup or restore your blockchain database.
You can configure where to store the session keys using `--keystore-path`.
Since you only use session keys for the parachain, there is no need to add this to the relaychain part of the command.

### Acquire the executable

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Native', value: 'Native'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Native">

We recommend following the [repository](https://github.com/KILTprotocol/mashnet-node).
Below is the command to connect as a Collator in the root directory of the mashnet-node repository.

:::info

Do not use master branch to compile the build.
Either use `develop` or the following tag `0.26.1`.

:::


```bash
./scripts/init.sh
cargo build --release -p kilt-parachain
```

The executable file can be found in `./target/release/kilt-parachain` after building the project.

</TabItem>
<TabItem value="Docker">

Simply pull the docker image:

```bash
docker pull kiltprotocol/peregrine:0.26.1
```

</TabItem>
</Tabs>

### Start the node

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Native', value: 'Native'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Native">


```
./target/release/kilt-parachain \
  --chain=./dev-specs/kilt-parachain/peregrine-kilt.json \
  --runtime=peregrine \
  --rpc-port=9933 \
  --rpc-cors=all \
  --rpc-methods=unsafe \
  --name "name of collator" \
  --execution=wasm \
  --listen-addr=/ip4/0.0.0.0/tcp/30336 \
  --base-path $HOME/data/parachain \
  --keystore-path $HOME/data/keystore \
  --collator \
  -- \
  --listen-addr=/ip4/0.0.0.0/tcp/30333 \
  --base-path $HOME/data/relay \
  --chain=./dev-specs/kilt-parachain/peregrine-relay.json \
  --execution=wasm
```

</TabItem>
<TabItem value="Docker">

```bash=
docker run -p 127.0.0.1:9933:9933 -v ~/data:/data \
    kiltprotocol/peregrine:0.26.1 \
    --rpc-port=9933 \
    --rpc-cors=all \
    --rpc-methods=unsafe \
    --chain=/node/dev-specs/kilt-parachain/peregrine-kilt.json \
    --runtime=peregrine \
    --execution=wasm \
    --listen-addr=/ip4/0.0.0.0/tcp/30336 \
    --name "name of collator" \
    --base-path /data/parachain \
    --keystore-path /data/keystore \
    --collator \
    -- \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --base-path /data/relay \
    --chain=/node/dev-specs/kilt-parachain/peregrine-relay.json \
    --execution=wasm
```

The docker commands will map the database files for the relay and parachain as well as the keystore directory to `~/data` on your host system using the flag `-v $HOME/data:/data`.
That way you can make sure to not lose those files when you remove the container.

The docker container runs as an user with id 1000.
The container will try to access the mapped volume and the files in it.
If the files are not owned by a user with id 1000 this will result in an error.
Run `chown -R 1000:1000 $HOME/data` to give the container access.


</TabItem>
</Tabs>

## Sync Data

Before a Collator can author blocks, the node needs to fully sync up with the blockchain.
Depending on which chain and the size of it may take a number of minutes to several hours maybe even a day.

More details can be found at the [Polkadot network](https://wiki.polkadot.network/docs/maintain-guides-how-to-validate-kusama#synchronize-chain-data)

## Session Keys

Once the chain has fully synced.
The collator will need sessions keys to begin collating on the network.
The session keys are important for collating within the network.
A Collator can call a RPC to check whether the account has session keys with the following calls `hasKey` and `hasSessionKeys` in `author`.

![](/img/chain/author-hasKey.png)

:::note

The Session keys associate a collator node with an account on KILT

:::

### Generate Session Keys

:::warning

Make sure that nobody is able to access your collator, but yourself.
The RPC endpoints must not be exposed!

:::

There are tree ways to create the session keys.
We recommend using the curl command on the same host that your node is running.
This way you don't need to add the `--unsafe-rpc-external` argument to your node.
But the session keys can also be rotated using the polkadot apps.


<Tabs
  defaultValue="curl"
  values={[
    {label: 'curl', value: 'curl'},
    {label: 'Apps', value: 'apps'},
    {label: 'Subkey', value: 'subkey'},
  ]}>
<TabItem value="curl">

#### Curl command

Running a remote node, a Collator can use the following command to rotate the session key.

```bash
curl -H "Content-Type: application/json" -d '{"id":1, "jsonrpc":"2.0", "method": "author_rotateKeys", "params":[]}' http://localhost:9933
```

The answer should look like the JSON object below.
The `result` key is the public key of your newly created session key.

```
{"jsonrpc":"2.0","result":"0xb2dc33b1ff0c6f8b07f882236bb992e903452791ff5225b5eb4c2c1a40252d5d","id":1}
```

</TabItem>
<TabItem value="apps">

First, a Collator needs to connect to a node using the polkadot apps.
For that, the Collator need to use ssh port forwarding.
The RPC endpoints must not be publicly available!

The RPC port can be forwarded using `ssh -L 127.0.0.1:9933:127.0.0.1:9933 <user>@<server>`.

![](/img/chain/chain-menu.png)

![](/img/chain/chain-selection.png)


Collators need to connect a running node to the [polkadot.js apps](https://polkadot.js.org/apps/#/explorer).

After connecting, a Collator must use an RPC with the associated Collator account to generate the keys.

The Extrinsic call in `author` and `rotateKeys`.
The method is used to generate a session key and rotate the existing key.

![](/img/chain/author-rotateKeys.png)

The rotation of the session key should be done periodically to ensure that the collator can remain secure and safe from attack.

</TabItem>
<TabItem value="subkey">

A key pair can be created using the [`subkey` tool](https://substrate.dev/docs/en/knowledgebase/integrate/subkey) and following the steps.
The corresponding private and public key can be used within the keystore folder of the local or remote server for the session key.

```
‚ùØ subkey generate -n kilt
Secret phrase `very secure private key you should not use the example private key` is account:
  Secret seed:      0xcafe97b4b8f0adc1adeb3feef30bf2e5b9d49ddd897f268c8027c850DeadBEEF
  Public key (hex): 0xda3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010
  Account ID:       0xda3861a45e0197f3ca145c2c209f9126e5053asdg03e459af4255cf8011d51010
  SS58 Address:     4srC1aowD94H9UH9xsnfv7XV6oHU6dhCymKYZHWKsdddaP29
```

The name of the file must be the public key prepended with `61757261` (hex representation of `aura`) and the content has to be the private key.

![](/img/chain/session-key-file.png)

Path in the root chain folder `./keystores/61757261da3861a45e0197f3ca145c2c209f9126e5053fas503e459af4255cf8011d51010`

</TabItem>
</Tabs>

The collator has a session key by following the previous steps.
The collator must then make an extrinsic by signing and submitting a transaction before the collator can begin collating on the network.
Visit the [polkadot apps and connect to the peregrine network](https://polkadot.js.org/apps/?rpc=wss%3A%2F%2Fperegrine.kilt.io#/explorer) (websocket address: `wss://peregrine.kilt.io`).

`Developer -> Extrinsics -> Submission`

1. Using the selected account: Select the Collator Account
2. Submit the following extrinsic: session -> setKeys(keys, proof)
3. Insert the key which was generated in the step "Generate Session Keys"

The proof of the `setKeys` is not used currently and can be set to `0x00`.

The Collator Account binds to the node.

![](/img/chain/session-setKeys.png)

:::info

A session takes 600 blocks or around 120~ minutes

:::

## Add collator

:::info

It is recommended to set the session keys before doing the following steps.

:::

The current number of collators is 17.

Once the session keys has been set, the collator can join the pool of collators.

A collator staking amount:
- minimum 10,000 KILT tokens 
- maximum 200,000 KILT tokens.

### Join collators

The collator must make an extrinsic call from the `parachainStaking` pallet with the method `joinCandidates` with the desired stake entering the `candidatePool`.

`Developer -> Extrinsics -> Submission`

1. Using the selected account: Select the Collator Account 
2. Submit the following extrinsic: parachainStaking -> joinCandidates(stake)
3. Insert the staked KILT amount for the collator 

![](/img/chain/parachainStaking-joinCandidates.png)

A collator can check the current `SelectedCandidates` to see the position and required staked amount to join the network. 

`Developer -> Chain state -> Storage`

1. Selected state query: `parachainStaking -> selectedCandidates(): Vec<AccountId>`
2. Add the item with the "+" on the right side

If the collator has enough self-stake and delegator stake they can be selected to collate.
Once the collator has been chosen, the collator will be added to the `SelectedCandidate` pool.
A time period of two sessions must pass before the collator will be authoring blocks, e.g.
after the rest of current session and the entire next one.

![](/img/chain/session-validators.png)

### Stake on collator

A collator can increase/decrease their stake.
The corresponding methods can be found as an extrinisc under `parachainStaking > candidateStakeMore / candidateStakeLess`.

![](/img/chain/parachainStaking.png)

## Monitoring

It would be ideal if monitoring is done from a different host.
However in cases of resource constraints it would be better to run these monitoring tools on the same machine where your collator is running than not having.
You can either run grafana by your own or subscribe free [grafana cloud ](https://grafana.com/products/cloud/) option. 

NB: if you want to use cloud option you need to expose prometheus to outside access via reverse proxying with webserver.
The following Monitoring stack is recommended.
- Prometheus
- Grafana
- Node exporter
- Slack
- Nginx

There are two types of metrics we are going to collect. **Node Exporter Metrics** and **Blockchain Metrics.**

### Prerequisite
Install latest version of docker-compose from the [official docker-compose installation guide](https://docs.docker.com/compose/install/)

Steps:

1. Clone or download our monitoring template from this link [KILTprotocol...](https://github.com/KILTprotocol/docs)
2. Change directory to the above cloned project's collator directory: ```cd docs/collator```
3. Edit .env file and insert grafana admin password
4. Run the following command if you want to install only prometheus and node exporter
   ```docker-compose up -d```
5. If you want to install prometheus with grafana ``` docker-compose up --profile grafana -d ```
6. if you want to install prometheus, grafana with  your collator  ``` docker-compose --profile collator --profile grafana up -d```

 Secure Endpoints:

- Install nginx with certbot ```sudo apt install nginx certbot python3-certbot-nginx ```
- If ufw is enabled allow Nginx Full : ```sudo ufw allow 'Nginx Full'```
- Generate SSL certeficate : ```sudo certbot --nginx -d ${DOMAIN_OF_SERVER_NAME}```
- Enable certeficate renewal    ```crontab -e``` and add at the end  of the file ```0 5 * * * /usr/bin/certbot renew --quiet```
- Reload nginx after you replace the default nginx file with prometheus endpoint (if you chose grafana cloud) or grafana endpoint (if grafana installed)
  ``` nano /etc/nginx/sites-enabled/default ``` 
  ```
   location / {
    proxy_pass http://localhost:9090/;    #proxy_pass http://localhost:3000/;
  
          }
  ```
- Enable basic Auth by replacing default pasxsword on prometheus.yml using  ``` htpasswd -nBC 10 "" | tr -d ':\n' ```

### Testing
You could open and check [localhost:3000 ](http://localhost:3000/d/JGBmHZI7k/kilt-spiritnet?orgId=1&refresh=10s) then authenticate with admin:ADMIN_PASSWORD you set in .env at step 3.

### Configuring Notification channel
Choose anyone of the notification channels and [follow this documentation ...](https://grafana.com/docs/grafana/latest/alerting/old-alerting/notifications/) so that you get alerts and notifications.



## Bootnodes

The bootnodes are required to connect to the peer to peer network and discover additional peers.
The addresses are included in the chain spec, so there is no need to add them as a parameter to the start command.
For the sake of completeness the bootnodes are listed below:

* Peregrines Parachain bootnodes:
  - `/dns4/bootnode.kilt.io/tcp/30340/p2p/12D3KooWALJtiCZzcUPVsCa5f5egGfQyFhPY67kKosDw95bJqK7M`
  - `/dns4/bootnode.kilt.io/tcp/30341/p2p/12D3KooWCRgcGtFRsvqxqgysiR6Ah9SAzUNkM12Ef9sy59ZEspSQ`
* Peregrines relaychain bootnodes:
  - `/dns4/bootnode.kilt.io/tcp/30350/p2p/12D3KooWEeezCpJauUmWw3zfgEtYzhZTc5LgukQYtGTMaZfzgVfE`
  - `/dns4/bootnode.kilt.io/tcp/30351/p2p/12D3KooWHq5j9tLdZEu4tnr6ii2k33zp5DCoKREQ6KzuabC9Gihu`
  - `/dns4/bootnode.kilt.io/tcp/30352/p2p/12D3KooWQ8iTGLH98zLz9BZmq5FXDmR1NytDsJ2VToXvcjvHV16a`
  - `/dns4/bootnode.kilt.io/tcp/30353/p2p/12D3KooWNWNptEoH443LVUgwC5kd7DBVoNYwQtJh6dp4TQxUsAST`

## Benchmarking (optional)

To enable benchmarking, the collator must enable the benchmarking feature from a new build of the `kilt-parachain`.

:::caution

Don't use this binary for running a Collator!

:::

```bash=
cargo build --release -p kilt-parchain --features=runtime-benchmark
```

The benchmarking can be run to compare hardware against the referenced hardware.
At the moment, we have benchmarked our Runtime on an AMD Ryzen 7 1700X with 64GB RAM and an NVMe SSD.
After executing the benchmarks on a Server compare the weights to the official weights.
Lower weights are always better.

The commands to execute the benchmarking can be found [here](https://github.com/KILTprotocol/mashnet-node/tree/develop/runtimes/spiritnet/src/weights) inside each file.

Below is an example of the `pallet_balances`.

```bash=
./target/release/kilt-parachain \
  benchmark \
  --chain=spiritnet-dev \
  --execution=wasm \
  --wasm-execution=Compiled \
  --heap-pages=4096 \
  --extrinsic=* \
  --pallet=parachain_staking \
  --steps=50 \
  --repeat=20 \
  --output \
  ./runtimes/spiritnet/src/weights/parachain_staking.rs \
  --template \
  ./.maintain/weight-template.hbs
```

## Connect to the Spiritnet

After you tested your setup on peregrine you might want to start collating for the spiritnet.
For that you need to change the chainspec for the relay chain and parachain.
The relay chain will change from the peregrine-relay chain to kusama.
The parachain chainspec and runtime will change from peregrine to spiritnet.

<Tabs
  groupId="exec-strategy"
  defaultValue="Docker"
  values={[
    {label: 'Native', value: 'Native'},
    {label: 'Docker', value: 'Docker'},
  ]}>
<TabItem value="Native">

```
./target/release/kilt-parachain \
  --chain=spiritnet \
  --runtime=spiritnet \
  --rpc-port=9933 \
  --rpc-cors=all \
  --rpc-methods=unsafe \
  --name "name of collator" \
  --execution=wasm \
  --listen-addr=/ip4/0.0.0.0/tcp/30336 \
  --base-path $HOME/data/parachain \
  --keystore-path $HOME/data/keystore \
  --collator \
  -- \
  --listen-addr=/ip4/0.0.0.0/tcp/30333 \
  --base-path $HOME/data/relay \
  --chain=kusama \
  --execution=wasm
```

</TabItem>
<TabItem value="Docker">

```bash=
docker run -p 127.0.0.1:9933:9933 -v ~/data:/data \
    kiltprotocol/peregrine:0.26.1 \
    --rpc-port=9933 \
    --rpc-cors=all \
    --rpc-methods=unsafe \
    --chain=spiritnet \
    --runtime=spiritnet \
    --execution=wasm \
    --listen-addr=/ip4/0.0.0.0/tcp/30336 \
    --name "name of collator" \
    --base-path /data/parachain \
    --keystore-path /data/keystore \
    --collator \
    -- \
    --listen-addr=/ip4/0.0.0.0/tcp/30333 \
    --base-path /data/relay \
    --chain=kusama \
    --execution=wasm
```

</TabItem>
</Tabs>

## Known Issues

The following are known issues and the possible solutions:

- running "cargo update -p environmental" could fix something
- Using the commands create a `/Data/` directory the folder could possibly be owned by the root user. Switching the ownership of the folder with `chown [options] user:group filename`. Solution found [here](https://serverfault.com/questions/106713/how-to-change-ownership-of-a-folder-using-terminal)

## Troubleshooting

There are a few things that you can check to make sure everything is setup correctly.

0. Check that your node is fully synced with the relaychain & parachain. (best and finalised block number is equal to the one shown in the polkadot apps & on subscan)
1. Check that you are a selected collator. Your address should be listed in `parachainStaking > selectedCandidates`
2. The parachainStaking pallet will register your address in the session pallet. Check that your address is listed in `session > validators`
3. Check that session keys are associated with your validatorId (aka AccountId). There should be a 32 Byte long public key stored in `session > nextKeys(your AccountId)`
4. Your node will only collate if it has the private key that belongs to the public key that you got in 3. Connect to your node and check with `author > hasKey(<pubKey from 3.>, aura)` if your node has the private key.
5. If your logs print the message that starts with a :gift: emoji you can skip steps 1-4 since your collator is building blocks. But they might not get included by the relay chain.
6. Check in the Polkadot Apps under `network > explorer` that your accountId is shown next to a block. You can be 100% sure that you produce blocks if you are listed there. If steps 1-5 all look fine for your collator but you don't see your blocks, you might not produce and send blocks fast enough. This can be caused by slow hardware or a slow internet connection. Also, note that a high bandwidth connection can still be slow if it has a high ping! Bandwidth != latency
