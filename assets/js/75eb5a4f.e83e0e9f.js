(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3437],{5380:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=5380,e.exports=n},9192:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>s,metadata:()=>d,toc:()=>h});var i=t(5893),o=t(1151),l=t(1909);const r="import fetch from 'node-fetch'\n\nimport * as Kilt from '@kiltprotocol/sdk-js'\n\nexport async function queryPublishedCredentials(\n  web3Name: Kilt.Did.Web3Name\n): Promise<Kilt.KiltPublishedCredentialCollectionV1> {\n  const api = Kilt.ConfigService.get('api')\n\n  const encodedDidForWeb3Name = await api.call.did.queryByWeb3Name(web3Name)\n  const {\n    document: { uri }\n  } = Kilt.Did.linkedInfoFromChain(encodedDidForWeb3Name)\n\n  console.log(`DID for \"${web3Name}\": ${uri}`)\n\n  const resolutionResult = await Kilt.Did.resolve(uri)\n  if (!resolutionResult) {\n    throw new Error('The DID does not exist on the KILT blockchain.')\n  }\n\n  const { document } = resolutionResult\n  // If no details are returned but resolutionResult is not null, the DID has been deleted.\n  // This information is present in `resolutionResult.metadata.deactivated`.\n  if (!document) {\n    throw new Error('The DID has already been deleted.')\n  }\n\n  // Filter the endpoints by their type.\n  const credentialEndpoints = document.service?.filter((service) =>\n    service.type.includes(Kilt.KiltPublishedCredentialCollectionV1Type)\n  )\n\n  console.log(\n    `Endpoints of type \"${Kilt.KiltPublishedCredentialCollectionV1Type}\" for the retrieved DID:`\n  )\n  console.log(JSON.stringify(credentialEndpoints, null, 2))\n\n  // For demonstration, only the first endpoint and its first URL are considered.\n  const firstCredentialCollectionEndpointUrl =\n    credentialEndpoints?.[0]?.serviceEndpoint[0]\n  if (!firstCredentialCollectionEndpointUrl) {\n    console.log(\n      `The DID has no services of type \"${Kilt.KiltPublishedCredentialCollectionV1Type}\".`\n    )\n  }\n\n  // Retrieve the credentials pointed at by the endpoint.\n  // Being an IPFS endpoint, the fetching can take an arbitrarily long time or even fail if the timeout is reached.\n  // In production settings, error cases including those where the result is not a correct JSON should be handled accordingly.\n  const response = await fetch(firstCredentialCollectionEndpointUrl as string)\n  const credentialCollection: Kilt.KiltPublishedCredentialCollectionV1 =\n    await response.json()\n  console.log(`Credential collection behind the endpoint:`)\n  console.log(JSON.stringify(credentialCollection, null, 2))\n\n  // Verify that all credentials are valid and that they all refer to the same subject DID.\n  await Promise.all(\n    credentialCollection.map(async ({ credential }) => {\n      const { revoked } = await Kilt.Credential.verifyCredential(credential)\n\n      // Verify that the credential is not revoked.\n      if (revoked) {\n        throw new Error(\n          'One of the credentials has been revoked, hence it is not valid.'\n        )\n      }\n\n      // Verify that the credential refers to the intended subject.\n      if (!Kilt.Did.isSameSubject(credential.claim.owner, uri)) {\n        throw new Error(\n          'One of the credentials refers to a different subject than expected.'\n        )\n      }\n    })\n  )\n\n  // If none of the above operations throw, the credentials are valid.\n  console.log('All retrieved credentials are valid! \u2705!')\n\n  return credentialCollection\n}\n",s={id:"credential-query",title:"Query Public Credentials for a web3name"},a=void 0,d={id:"develop/sdk/cookbook/web3names/credential-query",title:"Query Public Credentials for a web3name",description:"web3names are linked to KILT DIDs, and KILT DIDs can define services to expose additional service/information.",source:"@site/docs/develop/01_sdk/02_cookbook/02_web3names/02_credential_query.md",sourceDirName:"develop/01_sdk/02_cookbook/02_web3names",slug:"/develop/sdk/cookbook/web3names/credential-query",permalink:"/docs/develop/sdk/cookbook/web3names/credential-query",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/02_web3names/02_credential_query.md",tags:[],version:"current",lastUpdatedAt:1707216207,formattedLastUpdatedAt:"Feb 6, 2024",sidebarPosition:2,frontMatter:{id:"credential-query",title:"Query Public Credentials for a web3name"},sidebar:"sdk",previous:{title:"Claim a web3name",permalink:"/docs/develop/sdk/cookbook/web3names/web3name-claim"},next:{title:"Release a web3name",permalink:"/docs/develop/sdk/cookbook/web3names/web3name-release"}},c={},h=[];function u(e){const n={a:"a",code:"code",p:"p",...(0,o.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["web3names are linked to KILT DIDs, and KILT DIDs can define services to expose additional service/information.\nOne of the possible endpoint types is the ",(0,i.jsx)(n.a,{href:"https://github.com/KILTprotocol/spec-KiltPublishedCredentialCollectionV1/blob/main/README.md",children:(0,i.jsx)(n.code,{children:"KiltPublishedCredentialCollectionV1"})})," type.\nThe type defines the structure to make KILT credentials public and accessible to anyone."]}),"\n",(0,i.jsxs)(n.p,{children:["Because of the relationship between web3names and DIDs, it is possible, given a certain web3name, to retrieve all public credentials that the DID subject identified by that web3name has made available.\nBelow is a code snippet showing how to do that using the KILT SDK, and how to perform the needed security checks/validation as recommended by the ",(0,i.jsx)(n.a,{href:"https://github.com/KILTprotocol/spec-KiltPublishedCredentialCollectionV1/blob/main/README.md",children:"specification"}),"."]}),"\n",(0,i.jsx)(l.Z,{children:r})]})}function p(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},1909:(e,n,t)=>{"use strict";t.d(n,{Z:()=>p});var i=t(7294),o=t(2263),l=t(2175),r=t(4935),s=t(4990),a=t(9966),d=t(4866),c=t(5162),h=t(9286),u=t(5893);const p=e=>{let{children:n,fileName:t,...p}=e;const b=n,[f,m]=(0,i.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:w}}}=(0,o.Z)(),v=(0,i.useMemo)((()=>{const{code:e}=(0,l.transform)(b,{plugins:["transform-typescript"],retainLines:!0});return e}),[b]);(0,i.useEffect)((()=>{r.WU(v,{parser:"babel",plugins:[s.Z,a.ZP],...w}).then(m)}),[w,v]);const k=[{fileName:t?`${t}.ts`:void 0,fileContents:b,fileID:"ts",fileLabel:"Typescript"},{fileName:t?`${t}.js`:void 0,fileContents:f,fileID:"js",fileLabel:"Javascript"}];return(0,u.jsx)(u.Fragment,{children:(0,u.jsx)(d.Z,{groupId:"ts-js-choice",children:k.map((e=>(0,u.jsx)(c.Z,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,u.jsx)(h.Z,{...p,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);