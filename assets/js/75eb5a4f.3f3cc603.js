(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3694],{5764:e=>{function n(e){var n=new Error("Cannot find module '"+e+"'");throw n.code="MODULE_NOT_FOUND",n}n.keys=()=>[],n.resolve=n,n.id=5764,e.exports=n},4615:(e,n,t)=>{"use strict";t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>d,toc:()=>h});var i=t(4848),o=t(8453),r=t(3172);const l="import fetch from 'node-fetch'\n\nimport * as Kilt from '@kiltprotocol/sdk-js'\n\nexport async function queryPublishedCredentials(\n  web3Name: Kilt.Did.Web3Name\n): Promise<Kilt.KiltPublishedCredentialCollectionV1> {\n  const api = Kilt.ConfigService.get('api')\n\n  const encodedDidForWeb3Name = await api.call.did.queryByWeb3Name(web3Name)\n  const {\n    document: { uri }\n  } = Kilt.Did.linkedInfoFromChain(encodedDidForWeb3Name)\n\n  console.log(`DID for \"${web3Name}\": ${uri}`)\n\n  const resolutionResult = await Kilt.Did.resolve(uri)\n  if (!resolutionResult) {\n    throw new Error('The DID does not exist on the KILT blockchain.')\n  }\n\n  const { document } = resolutionResult\n  // If no details are returned but resolutionResult is not null, the DID has been deleted.\n  // This information is present in `resolutionResult.metadata.deactivated`.\n  if (!document) {\n    throw new Error('The DID has already been deleted.')\n  }\n\n  // Filter the endpoints by their type.\n  const credentialEndpoints = document.service?.filter((service) =>\n    service.type.includes(Kilt.KiltPublishedCredentialCollectionV1Type)\n  )\n\n  console.log(\n    `Endpoints of type \"${Kilt.KiltPublishedCredentialCollectionV1Type}\" for the retrieved DID:`\n  )\n  console.log(JSON.stringify(credentialEndpoints, null, 2))\n\n  // For demonstration, only the first endpoint and its first URL are considered.\n  const firstCredentialCollectionEndpointUrl =\n    credentialEndpoints?.[0]?.serviceEndpoint[0]\n  if (!firstCredentialCollectionEndpointUrl) {\n    console.log(\n      `The DID has no services of type \"${Kilt.KiltPublishedCredentialCollectionV1Type}\".`\n    )\n  }\n\n  // Retrieve the credentials pointed at by the endpoint.\n  // Being an IPFS endpoint, the fetching can take an arbitrarily long time or even fail if the timeout is reached.\n  // In production settings, error cases including those where the result is not a correct JSON should be handled accordingly.\n  const response = await fetch(firstCredentialCollectionEndpointUrl as string)\n  const credentialCollection: Kilt.KiltPublishedCredentialCollectionV1 =\n    await response.json()\n  console.log(`Credential collection behind the endpoint:`)\n  console.log(JSON.stringify(credentialCollection, null, 2))\n\n  // Verify that all credentials are valid and that they all refer to the same subject DID.\n  await Promise.all(\n    credentialCollection.map(async ({ credential }) => {\n      const { revoked } = await Kilt.Credential.verifyCredential(credential)\n\n      // Verify that the credential is not revoked.\n      if (revoked) {\n        throw new Error(\n          'One of the credentials has been revoked, hence it is not valid.'\n        )\n      }\n\n      // Verify that the credential refers to the intended subject.\n      if (!Kilt.Did.isSameSubject(credential.claim.owner, uri)) {\n        throw new Error(\n          'One of the credentials refers to a different subject than expected.'\n        )\n      }\n    })\n  )\n\n  // If none of the above operations throw, the credentials are valid.\n  console.log('All retrieved credentials are valid! \u2705!')\n\n  return credentialCollection\n}\n",a={id:"credential-query",title:"Query Public Credentials for a web3name"},s=void 0,d={id:"develop/sdk/cookbook/web3names/credential-query",title:"Query Public Credentials for a web3name",description:"web3names are linked to KILT DIDs, and KILT DIDs can define services to expose additional service/information.",source:"@site/docs/develop/01_sdk/02_cookbook/02_web3names/02_credential_query.md",sourceDirName:"develop/01_sdk/02_cookbook/02_web3names",slug:"/develop/sdk/cookbook/web3names/credential-query",permalink:"/docs/develop/sdk/cookbook/web3names/credential-query",draft:!1,unlisted:!1,editUrl:"https://github.com/KILTprotocol/docs/edit/master/docs/develop/01_sdk/02_cookbook/02_web3names/02_credential_query.md",tags:[],version:"current",lastUpdatedAt:1733496053e3,sidebarPosition:2,frontMatter:{id:"credential-query",title:"Query Public Credentials for a web3name"},sidebar:"sdk",previous:{title:"Claim a web3name",permalink:"/docs/develop/sdk/cookbook/web3names/web3name-claim"},next:{title:"Release a web3name",permalink:"/docs/develop/sdk/cookbook/web3names/web3name-release"}},c={},h=[];function u(e){const n={a:"a",code:"code",p:"p",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["web3names are linked to KILT DIDs, and KILT DIDs can define services to expose additional service/information.\nOne of the possible endpoint types is the ",(0,i.jsx)(n.a,{href:"https://github.com/KILTprotocol/spec-KiltPublishedCredentialCollectionV1/blob/main/README.md",children:(0,i.jsx)(n.code,{children:"KiltPublishedCredentialCollectionV1"})})," type.\nThe type defines the structure to make KILT credentials public and accessible to anyone."]}),"\n",(0,i.jsxs)(n.p,{children:["Because of the relationship between web3names and DIDs, it is possible, given a certain web3name, to retrieve all public credentials that the DID subject identified by that web3name has made available.\nBelow is a code snippet showing how to do that using the KILT SDK, and how to perform the needed security checks/validation as recommended by the ",(0,i.jsx)(n.a,{href:"https://github.com/KILTprotocol/spec-KiltPublishedCredentialCollectionV1/blob/main/README.md",children:"specification"}),"."]}),"\n",(0,i.jsx)(r.A,{children:l})]})}function p(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},3172:(e,n,t)=>{"use strict";t.d(n,{A:()=>p});var i=t(6540),o=t(4586),r=t(6352),l=t(8463),a=t(5283),s=t(6745),d=t(1470),c=t(9365),h=t(1432),u=t(4848);const p=e=>{let{children:n,fileName:t,...p}=e;const m=n,[f,b]=(0,i.useState)("# loading code..."),{siteConfig:{customFields:{prettierConfig:w}}}=(0,o.A)(),v=(0,i.useMemo)((()=>{const{code:e}=(0,r.transform)(m,{plugins:["transform-typescript"],retainLines:!0}),n=["./generateAccount","./generateKeypairs","./ctypeSchema","./createClaim","./generateLightDid","../attester/ctypeSchema","../claimer/generateLightDid","../claimer/generateCredential","./claimer/createPresentation","./claimer/generateKeypairs","./claimer/generateLightDid"];let t=e.replace(/from\s+['"](.+)['"]/g,((e,t)=>n.includes(t)?`from '${t}.js'`:e));return t=t.replace("if (require.main === module)","if (process.argv[1] === new URL(import.meta.url).pathname)"),t}),[m]);(0,i.useEffect)((()=>{l.GP(v,{parser:"babel",plugins:[a.A,s.Ay],...w}).then(b)}),[w,v]);const y=[{fileName:t?`${t}.ts`:void 0,fileContents:m,fileID:"ts",fileLabel:"Typescript"},{fileName:t?`${t}.js`:void 0,fileContents:f,fileID:"js",fileLabel:"Javascript"}];return(0,u.jsx)(u.Fragment,{children:(0,u.jsx)(d.A,{groupId:"ts-js-choice",children:y.map((e=>(0,u.jsx)(c.A,{value:e.fileID,label:e.fileLabel,default:!0,children:(0,u.jsx)(h.A,{...p,className:"language-"+e.fileID,title:e.fileName,children:e.fileContents})})))})})}}}]);